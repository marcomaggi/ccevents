\input texinfo.tex
@c %**start of header
@setfilename ccevents.info
@settitle CCEvents
@c %**end of header

@include version.texi
@include macros.texi

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      CCEvents

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    CCEvents

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           ccevents

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{marco.maggi-ipsu@@poste.it}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2017

@c ------------------------------------------------------------

@set GITHUB_URL                 @url{http://github.com/marcomaggi/@value{PACKAGE_NICKNAME}}
@set BITBUCKET_URL              @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}}
@set DOWNLOAD_URL               @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}/downloads}
@set DOCUMENTATION_URL          @url{http://marcomaggi.github.io/docs/@value{PACKAGE_NICKNAME}.html}

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
This document describes version @value{VERSION} of @value{PACKAGE}, a C language library
implementing an event loop.  It is written in C11 with @gcc{} extensions.

The package is distributed under the terms of the @gnu{} Lesser General Public License (@lgpl{}).

The latest release can be downloaded from:

@center @value{DOWNLOAD_URL}

@noindent
development takes place at:

@center @value{GITHUB_URL}

@noindent
and as backup at:

@center @value{BITBUCKET_URL}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the @gnu{} Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with
Invariant Sections being ``@gnu{} Free Documentation License'' and
``@gnu{} General Public License'', no Front--Cover Texts, and no
Back--Cover Texts.  A copy of the license is included in the section
entitled ``@gnu{} Free Documentation License''.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @value{VERSION}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* ccevents: (ccevents).         CCEvents an events loop library.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* init::                        Library initialisation.
* version::                     Version functions.
* conditions::                  Exceptional condition objects.
* timevals::                    Handling time spans.
* timeouts::                    Handling event expiration times.
* fd::                          Event source for file descriptors.

Appendices

* Package License::             GNU Lesser General Public License.
* Documentation License::       GNU Free Documentation License.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


This document describes version @value{VERSION} of @value{PACKAGE}, a C language library
implementing an event loop.  It is written in C11 with @gcc{} extensions.

This package depends on the package CCExceptions, at least version 0.2; @ref{references} for details
on downloading it.

@value{PACKAGE} installs the single header file @file{ccevents.h}.  All the function names in the
@api{} are prefixed with @code{cct_}; all the constant names are prefixed with @code{CCT_}; all the
type names are prefixed with @code{cct_} and suffixed with @code{_t}.

The events loop implementation is inspired by the architecture of the event loop of
@url{http://www.tcl.tk/, Tcl}; though no code comes from Tcl.

Notice that, before using the library, we need to call the global initialisation function
@cfunc{ccevents_init}.

@menu
* overview linking::            Linking code with the library.
@end menu

@c page
@node overview linking
@section Linking code with the library


This package installs a data file for @command{pkg-config}, so when searching for the installed
library with the @gnu{} Autotools, we can add the following macro use to @file{configure.ac}:

@example
PKG_CHECK_MODULES([CCEVENTS],[ccevents >= 0.1])
@end example

@noindent
which will set the variables @code{CCEVENTS_LIBS} and @code{CCEVENTS_CFLAGS}.

Alternatively we can use the raw @gnu{} Autoconf macros:

@example
AC_CHECK_LIB([ccevents],[cct_version_string],,
  [AC_MSG_FAILURE([test for CCEvents library failed])])
AC_CHECK_HEADERS([ccevents.h],,
  [AC_MSG_FAILURE([test for CCEvents header failed])])
@end example

We need to remember that client code using @value{PACKAGE}'s library must be written using the C11
language and the @gcc{} extensions enabled by @option{-fplan9-extensions}.

@c page
@node init
@chapter Library initialisation


@deftypefun void ccevents_init (void)
Initialises the internal structures of the library.  It is fine to call this function multiple
times.
@end deftypefun

@c page
@node version
@chapter Version functions


The installed libraries follow version numbering as established by the
@gnu{} Autotools.  For an explanation of interface numbers as managed by
@gnu{} Libtool @xref{Libtool versioning, interface, Libtool's versioning
system, libtool, Shared library support for @gnu{}}.


@deftypefun {const char *} cct_version_string (void)
Return a pointer to a statically allocated @asciiz{} string representing
the interface version number.
@end deftypefun


@deftypefun int cct_version_interface_current (void)
Return an integer representing the library interface current number.
@end deftypefun


@deftypefun int cct_version_interface_revision (void)
Return an integer representing the library interface current revision
number.
@end deftypefun


@deftypefun int cct_version_interface_age (void)
Return an integer representing the library interface current age.
@end deftypefun

@c page
@node conditions
@chapter Exceptional condition objects


@value{PACKAGE} makes use of the external library CCExceptions to signal exceptional conditions and
errors through non--local exits; @xref{Top, CCExceptions, CCExceptions, ccexceptions, CCExceptions}.
The functions will raise exceptional conditions with @cfunc{cce_raise} and expect the caller to
intercept them using the @code{cce_location_t} mechanics.

@menu
* conditions base::             Base exceptional conditions.
* conditions timeval::          Timeval exceptional conditions.
* conditions timeout::          Timeout exceptional conditions.
@end menu

@c page
@node conditions base
@section Base exceptional conditions


@cindex Base exceptional condition
@cindex Exceptional conditions, base


@deftp {Struct Typedef} ccevents_condition_base_descriptor_t
Type of data structure representing the base exceptional condition descriptor for all the conditions
defined by this library.  It has the following public fields:

@table @code
@item cce_condition_descriptor_t
Anonymous field representing the condition descriptor's base values.
@end table

The parent of this type descriptor is @code{cce_root_condition_descriptor} as defined by the
CCExceptions library.  @xref{conditions root, CCExceptions, CCExceptions, ccexceptions,
CCExceptions}.
@end deftp


@deftypevr {Dynamic Constant} {const ccevents_condition_base_descriptor_t *} ccevents_base_condition_descriptor
Pointer to a statically allocated exceptional condition descriptor.
@end deftypevr


@deftypefun bool ccevents_condition_is_a_base (const cce_condition_t * @var{C})
Return @true{} if @var{C} is an exceptional condition object of with type descriptor
@objtype{ccevents_condition_base_descriptor_t}; otherwise return @false{}.
@end deftypefun

@c page
@node conditions timeval
@section Timeval exceptional conditions


@menu
* timevals conditions timeval::         Timeval exceptional conditions.
* timevals conditions invalid::         Invalid timeval values.
* timevals conditions overflow::        Overflow in timeval representation.
@end menu

@c page
@node timevals conditions timeval
@subsection Timeval exceptional conditions


@cindex Timeval, exceptional condition
@cindex Exceptional conditions, timeval


@deftp {Struct Typedef} ccevents_condition_timeval_descriptor_t
Type of data structure representing a generic exceptional condition descriptor for all the
timeval--related errors; it is the base for all the timeval--related condition object types.  It has
the following public fields:

@table @code
@item cce_condition_descriptor_t
Anonymous field representing the condition descriptor's base values.
@end table

The parent of this type descriptor is the descriptor referenced by
@code{ccevents_condition_base_descriptor}.
@end deftp


@deftp {Struct Typedef} ccevents_condition_timeval_t
Type of data structure representing an exceptional condition objects for a generic timeval--related
error.  It has the following public fields:

@table @code
@item cce_condition_t
Anonymous field representing the condition object's base values.
@end table
@end deftp


@deftypevr {Constant} {const ccevents_condition_timeval_descriptor_t *} ccevents_condition_timeval_descriptor
Pointer to a statically allocated exceptional condition descriptor.
@end deftypevr


@deftypefun {const ccevents_condition_timeval_t *} ccevents_condition_timeval (void)
Return a pointer to exceptional condition object.  The returned object must be released with a
proper call to @cfunc{cce_condition_free}.
@end deftypefun


@deftypefun bool ccevents_condition_is_a_timeval (const cce_condition_t * @var{C})
Return @true{} if @var{C} is an exceptional condition object of with type descriptor
@objtype{ccevents_condition_timeval_descriptor_t}; otherwise return @false{}.
@end deftypefun


To catch this exceptional condition we can to:

@smallexample
cce_location_t        L;
ccevents_timeval_t    to;

if (cce_location(L)) @{
  cce_condition_t * C = cce_location_condition(L);

  if (ccevents_condition_is_a_timeval(C)) @{
    ccevents_condition_timeval_t * K = \
      (ccevents_condition_timeval_t *)C;
    do_something_with(K);
  @}
  cce_condition_free(C);
  cce_run_error_handlers(L);
@} else @{
  do_something(L);
  cce_run_cleanup_handlers(L);
@}
@end smallexample

@c page
@node timevals conditions invalid
@subsection Invalid timeval values


@cindex Invalid timeval, exceptional condition
@cindex Timeval, invalid exceptional condition
@cindex Exceptional conditions, invalid timeval


@deftp {Struct Typedef} ccevents_condition_timeval_invalid_descriptor_t
Type of data structure representing the exceptional condition descriptor for ``invalid timeval
initialisation'' errors.  It has the following public fields:

@table @code
@item cce_condition_descriptor_t
Anonymous field representing the condition descriptor's base values.
@end table

The parent of this type descriptor is the descriptor referenced by
@code{ccevents_condition_timeval_descriptor}.
@end deftp


@deftp {Struct Typedef} ccevents_condition_timeval_invalid_t
Type of data structure representing exceptional condition objects for ``invalid timeval
initialisation'' errors.  It has the following public fields:

@table @code
@item cce_condition_t
Anonymous field representing the condition object's base values.
@end table
@end deftp


@deftypevr {Constant} {const ccevents_condition_timeval_invalid_descriptor_t *} ccevents_condition_timeval_invalid_descriptor
Pointer to a statically allocated exceptional condition descriptor.
@end deftypevr


@deftypefun {const ccevents_condition_timeval_invalid_t *} ccevents_condition_timeval_invalid (void)
Return a pointer to exceptional condition object.  The returned object must be released with a
proper call to @cfunc{cce_condition_free}.
@end deftypefun


@deftypefun bool ccevents_condition_is_a_timeval_invalid (const cce_condition_t * @var{C})
Return @true{} if @var{C} is an exceptional condition object of with type descriptor
@objtype{ccevents_condition_timeval_invalid_descriptor_t}; otherwise return @false{}.
@end deftypefun


To catch this exceptional condition we can to:

@smallexample
cce_location_t        L;
ccevents_timeval_t    to;

if (cce_location(L)) @{
  cce_condition_t * C = cce_location_condition(L);

  if (ccevents_condition_is_a_timeval_invalid(C)) @{
    ccevents_condition_timeval_invalid_t * K = \
      (ccevents_condition_timeval_invalid_t *)C;
    do_something_with(K);
  @}
  cce_condition_free(C);
  cce_run_error_handlers(L);
@} else @{
  do_something(L);
  cce_run_cleanup_handlers(L);
@}
@end smallexample

@c page
@node timevals conditions overflow
@subsection Overflow in timeval representation


@cindex Timeval, overflow exceptional condition
@cindex Overflow in timeval, exceptional condition
@cindex Exceptional conditions, overflow in timeval


@deftp {Struct Typedef} ccevents_condition_timeval_overflow_descriptor_t
Type of data structure representing the exceptional condition descriptor for ``timeval
initialisation overflow'' errors.  It has the following public fields:

@table @code
@item cce_condition_descriptor_t
Anonymous field representing the condition descriptor's base values.
@end table

The parent of this type descriptor is the descriptor referenced by
@code{ccevents_condition_timeval_descriptor}.
@end deftp


@deftp {Struct Typedef} ccevents_condition_timeval_overflow_t
Type of data structure representing exceptional condition objects for ``timeval initialisation
overflow'' errors.  It has the following public fields:

@table @code
@item cce_condition_t
Anonymous field representing the condition object's base values.
@end table
@end deftp


@deftypevr {Constant} {const ccevents_condition_timeval_overflow_descriptor_t *} ccevents_condition_timeval_overflow_descriptor
Pointer to a statically allocated exceptional condition descriptor.
@end deftypevr


@deftypefun {const ccevents_condition_timeval_overflow_t *} ccevents_condition_timeval_overflow (void)
Return a pointer to exceptional condition object.  The returned object must be released with a
proper call to @cfunc{cce_condition_free}.
@end deftypefun


@deftypefun bool ccevents_condition_is_a_timeval_overflow (const cce_condition_t * @var{C})
Return @true{} if @var{C} is an exceptional condition object of with type descriptor
@objtype{ccevents_condition_timeval_overflow_descriptor_t}; otherwise return @false{}.
@end deftypefun


To catch this exceptional condition we can to:

@smallexample
cce_location_t        L;
ccevents_timeval_t    to;

if (cce_location(L)) @{
  cce_condition_t * C = cce_location_condition(L);

  if (ccevents_condition_is_a_timeval_overflow(C)) @{
    ccevents_condition_timeval_overflow_t * K = \
      (ccevents_condition_timeval_overflow_t *)C;
    do_something_with(K);
  @}
  cce_condition_free(C);
  cce_run_error_handlers(L);
@} else @{
  do_something(L);
  cce_run_cleanup_handlers(L);
@}
@end smallexample

@c page
@node conditions timeout
@section Timeout exceptional conditions


@menu
* timeouts conditions invalid::         Invalid timeout values.
* timeouts conditions overflow::        Overflow in timeout representation.
@end menu

@c page
@node timeouts conditions invalid
@subsection Invalid timeout values


@deftp {Struct Typedef} ccevents_condition_descriptor_timeout_invalid_t
Type of data structure representing the exceptional condition descriptor for ``invalid timeout
initialisation'' errors.  It has the following public fields:

@table @code
@item cce_condition_descriptor_t
Anonymous field representing the condition descriptor's base values.
@end table

The parent of this type descriptor is the descriptor referenced by @code{ccevents_base_condition_descriptor}.
@end deftp


@deftp {Struct Typedef} ccevents_condition_timeout_invalid_t
Type of data structure representing exceptional condition objects for ``invalid timeout
initialisation'' errors.  It has the following public fields:

@table @code
@item cce_condition_t
Anonymous field representing the condition object's base values.
@end table
@end deftp


@deftypevr {Constant} {const ccevents_condition_descriptor_timeout_invalid_t *} ccevents_condition_timeout_invalid_descriptor
Pointer to a statically allocated exceptional condition descriptor.
@end deftypevr


@deftypefun {const ccevents_condition_timeout_invalid_t *} ccevents_condition_timeout_invalid (void)
Return a pointer to exceptional condition object.  The returned object must be released with a
proper call to @cfunc{cce_condition_free}.
@end deftypefun


@deftypefun bool ccevents_condition_is_a_timeout_invalid (const cce_condition_t * @var{C})
Return @true{} if @var{C} is an exceptional condition object of with type descriptor
@objtype{ccevents_condition_descriptor_timeout_invalid_t}; otherwise return @false{}.
@end deftypefun


To catch this exceptional condition we can to:

@smallexample
cce_location_t        L;
ccevents_timeout_t    to;

if (cce_location(L)) @{
  cce_condition_t * C = cce_location_condition(L);

  if (ccevents_condition_is_a_timeval_invalid(C)) @{
    ccevents_condition_timeout_invalid_t * K = \
      (ccevents_condition_timeout_invalid_t *)C;
    do_something_with(K);
  @}
  cce_condition_free(C);
  cce_run_error_handlers(L);
@} else @{
  do_something(L);
  cce_run_cleanup_handlers(L);
@}
@end smallexample

@c page
@node timeouts conditions overflow
@subsection Overflow in timeout representation


@deftp {Struct Typedef} ccevents_condition_descriptor_timeout_overflow_t
Type of data structure representing the exceptional condition descriptor for ``timeout
initialisation overflow'' errors.  It has the following public fields:

@table @code
@item cce_condition_descriptor_t
Anonymous field representing the condition descriptor's base values.
@end table

The parent of this type descriptor is the descriptor referenced by
@code{ccevents_base_condition_descriptor}.
@end deftp


@deftp {Struct Typedef} ccevents_condition_timeout_overflow_t
Type of data structure representing exceptional condition objects for ``timeout initialisation
overflow'' errors.  It has the following public fields:

@table @code
@item cce_condition_t
Anonymous field representing the condition object's base values.
@end table
@end deftp


@deftypevr {Constant} {const ccevents_condition_descriptor_timeout_overflow_t *} ccevents_condition_timeout_overflow_descriptor
Pointer to a statically allocated exceptional condition descriptor.
@end deftypevr


@deftypefun {const ccevents_condition_timeout_overflow_t *} ccevents_condition_timeout_overflow (void)
Return a pointer to exceptional condition object.  The returned object must be released with a
proper call to @cfunc{cce_condition_free}.
@end deftypefun


@deftypefun bool ccevents_condition_is_a_timeout_overflow (const cce_condition_t * @var{C})
Return @true{} if @var{C} is an exceptional condition object of with type descriptor
@objtype{ccevents_condition_descriptor_timeout_overflow_t}; otherwise return @false{}.
@end deftypefun


To catch this exceptional condition we can to:

@smallexample
cce_location_t        L;
ccevents_timeout_t    to;

if (cce_location(L)) @{
  cce_condition_t * C = cce_location_condition(L);

  if (ccevents_condition_is_a_timeout_overflow(C)) @{
    ccevents_condition_timeout_overflow_t * K = \
      (ccevents_condition_timeout_overflow_t *)C;
    do_something_with(K);
  @}
  cce_condition_free(C);
  cce_run_error_handlers(L);
@} else @{
  do_something(L);
  cce_run_cleanup_handlers(L);
@}
@end smallexample

@c page
@node timevals
@chapter Handling time spans


It is typical for a C language system function, under a Unix--like system, to require a @code{struct
timeval} value to represent a time span; @value{PACKAGE} implements an @api{} to handle such
objects.

The @api{} is peculiar because often it requires the whole data structure to passed by value, rather
than using a pointer to structure as is usually the case.


@deftp {Struct Typedef} ccevents_timeval_t
An alias for @objtype{struct timeval} used to represent normalised values.  A normalised value is
such that the fields @code{tv_sec} and @code{tv_usec} obey the following constraints:

@example
0 <= tv_sec  <= LONG_MAX
0 <= tv_usec <= 999999
@end example

This type has the following public fields:

@table @code
@item struct timeval;
An anonymous field.
@end table
@end deftp


@deftypefun ccevents_timeval_t ccevents_timeval_init (cce_location_tag_t * there, long @var{seconds}, long @var{microseconds})
Build and return a timeval structure initialised and normalised with the given arguments.  If an
error occurs while normalising: an exception is raised by performing a non--local exit to
@var{there}.

The argument @var{seconds} is meant to be in the range @samp{[0, LONG_MAX]}.  The argument
@var{microseconds} is meant to be in the range @samp{[LONG_MIN, LONG_MAX]}.
@end deftypefun


@deftypefun ccevents_timeval_t ccevents_timeval_normalise (cce_location_tag_t * @var{there}, struct timeval @var{T})
Build and return a timeval structure initialised and normalised with the given arguments.  If an
error occurs while normalising: an exception is raised by performing a non--local exit to
@var{there}.

The field @code{tv_sec} of @var{T} is meant to be in the range @samp{[0, LONG_MAX]}.  The field
@code{tv_usec} of @var{T} is meant to be in the range @samp{[LONG_MIN, LONG_MAX]}.
@end deftypefun


@deftypefun ccevents_timeval_t ccevents_timeval_add (cce_location_tag_t * @var{there}, ccevents_timeval_t @var{A}, ccevents_timeval_t @var{B})
Add the two timeval values @var{A} and @var{B} and return a normalised timeval value.  If an error
occurs while adding or normalising: an exception is raised by performing a non--local exit to
@var{there}.
@end deftypefun


@deftypefun ccevents_timeval_t ccevents_timeval_sub (cce_location_tag_t * @var{there}, ccevents_timeval_t @var{A}, ccevents_timeval_t @var{B})
Subtract @var{B} from @var{A} and return a normalised timeval value representing the difference.  If
an error occurs while subtracting or normalising: an exception is raised by performing a non--local
exit to @var{there}.
@end deftypefun


@deftypefun int ccevents_timeval_compare (ccevents_timeval_t @var{A}, ccevents_timeval_t @var{B})
Compare the timeval values @var{A} and @var{B}.  Return:

@table @code
@item 0
If @var{A} is equal to @var{B}.

@item +1
If @var{A} is greater than @var{B}.

@item -1
If @var{A} is less than @var{B}.
@end table
@end deftypefun


@c page
@node timeouts
@chapter Handling event expiration times


This module implements ``polling timeouts''.

@menu
* timeouts typedefs::           Type definitions.
* timeouts init::               Constructors.
* timeouts getters::            Getter functions.
* timeouts predicates::         Predicates.
* timeouts comparison::         Comparison.
* timeouts operations::         Operations.
@end menu

@c page
@node timeouts typedefs
@section Type definitions


@deftp {Struct Typedef} ccevents_timeout_t
Represents a time span from a point in time towards the future.  It is meant to be used to signal
that an event has not happended in a fixed amount of time.

Holds values for seconds, milliseconds and microseconds as @code{long int}.  The number of seconds
can only be zero or positive; the numbers of milliseconds and microseconds are normalised by
@cfunc{ccevents_timeout_init} to the range @code{[0, 999]}; the normalisation process can lead to an
overflow, which is signalled by raising an exception.

The maximum representable time span is: @code{LONG_MAX-1} seconds, @code{999} milliseconds,
@code{999} microseconds.  When the number of seconds is set to @code{LONG_MAX}: the time span is
interpreted as ``infinite'', the timeout will never expire.

An instance of this structure type is also an instance of @code{struct timeval}.

To copy a timeout data structure we can use the C language @code{=} operator.
@end deftp

@c page
@node timeouts init
@section Constructors


@deftypefun void ccevents_timeout_init (cce_location_tag_t * @var{there}, ccevents_timeout_t * @var{to}, long @var{seconds}, long @var{milliseconds}, long @var{microseconds})
Initialise an already allocated timeout structure.  The arguments @var{seconds}, @var{milliseconds}
and @var{microseconds} represent a time span towards the future:

@table @var
@item seconds
It is a count of seconds; it must be in the range @code{[0, LONG_MAX]}.  It is normalised to the
range @code{[0, LONG_MAX]}.

@item milliseconds
It is a count of milliseconds; it must be in the range @code{[LONG_MIN, LONG_MAX]}.  It is
normalised to the range @code{[0, 999]}.

@item microseconds
It is a count of microseconds; it must be in the range @code{[LONG_MIN, LONG_MAX]}.  It is
normalised to the range @code{[0, 999]}.
@end table

If an error occurs while normalising the given time span specification: raise an exception by
performing a non--local exit to @var{there}.
@end deftypefun


@deftypevr {Dynamic Constant} {const ccevents_timeout_t *} CCEVENTS_TIMEOUT_NEVER
Pointer to a constant, statically allocated instance of @objtype{ccevents_timeout_t} representing a
timeout that never expires.
@end deftypevr


@deftypevr {Dynamic Constant} {const ccevents_timeout_t *} CCEVENTS_TIMEOUT_NOW
Pointer to a constant, statically allocated instance of @objtype{ccevents_timeout_t} representing a
timeout that expires immediately.
@end deftypevr

@c page
@node timeouts getters
@section Getter functions


@deftypefn {Inline Function} long ccevents_timeout_seconds (const ccevents_timeout_t * @var{to})
Return the current number of seconds.  The value is in the range @code{[0, LONG_MAX]}.
@end deftypefn


@deftypefn {Inline Function} long ccevents_timeout_milliseconds (const ccevents_timeout_t * @var{to})
Return the current number of milliseconds.  The value is in the range @code{[0, 999]}.
@end deftypefn


@deftypefn {Inline Function} long ccevents_timeout_microseconds (const ccevents_timeout_t * @var{to})
Return the current number of microseconds.  The value is in the range @code{[0, 999]}.
@end deftypefn


@deftypefun ccevents_timeval_t ccevents_timeout_time_span (const ccevents_timeout_t * @var{to})
Return a timeval structure representing the current time span referenced by @var{to}.  The value in
the field @code{tv_sec} is in the range @code{[0, LONG_MAX]}, while the value in the field
@code{tv_usec} is in the range @code{[0, 999999]}.
@end deftypefun


@deftypefun ccevents_timeval_t ccevents_timeout_time (const ccevents_timeout_t * @var{to})
Return a timeval structure representing the current expiration absolute time; the returned value is
meaningful only if the timeout has been started.  The value in the field @code{tv_sec} is in the
range @code{[0, LONG_MAX]}, while the value in the field @code{tv_usec} is in the range @code{[0,
999999]}.
@end deftypefun

@c page
@node timeouts predicates
@section Predicates


@deftypefun bool ccevents_timeout_infinite_time_span (const ccevents_timeout_t * @var{to})
Return true if @var{to} represents an ``infinite'' time span: one for which
@cfunc{ccevents_timeout_expired} will never return true.
@end deftypefun


@deftypefun bool ccevents_timeout_expired (const ccevents_timeout_t * @var{to})
Acquire the current time and compare it with the expiration time.  Return true if the timeout has
expired; otherwise return false.
@end deftypefun

@c page
@node timeouts comparison
@section Comparison functions


@deftypefun int ccevents_timeout_compare_time_span (const ccevents_timeout_t * @var{A}, const ccevents_timeout_t * @var{B})
Compare the time spans of two timeouts; return: @code{-1} if @code{@var{A} < @var{B}}, @code{0} if
@code{@var{A} == @var{B}}, @code{+1} if @code{@var{A} > @var{B}}.
@end deftypefun


@deftypefun int ccevents_timeout_compare_expiration_time (const ccevents_timeout_t * @var{A}, const ccevents_timeout_t * @var{B})
Compare the expiration times of two timeouts; return: @code{-1} if @code{@var{A} < @var{B}}, @code{0}
if @code{@var{A} == @var{B}}, @code{+1} if @code{@var{A} > @var{B}}.
@end deftypefun

@c page
@node timeouts operations
@section Operations


@deftypefun void ccevents_timeout_start (cce_location_tag_t * @var{there}, ccevents_timeout_t * @var{to})
Start the timer associated to the already initialised @var{to} object: acquire the current absolute
time and compute the time instant that will expire the timeout.  The expiration time is stored in
the structure referenced by @var{to}.  As a special case: if the time span is infinite, the
expiration time is set to: @code{LONG_MAX} seconds; this should guarantee that @var{to} will never
expire.  If an error occurs: raise an exception by performing a non--local exit to @var{there}.
@end deftypefun


@deftypefun void ccevents_timeout_reset (ccevents_timeout_t * @var{to})
Reset a timeout, ``stop'' the timer.  The expiration time is set to a value meaning infinite
expiration time.
@end deftypefun

@c page
@node fd
@chapter Event source for file descriptors


@menu
* fd typedefs::                 Type definitions.
* fd init::                     Initialisation and setup.
* fd query::                    Predefined query functions.
@end menu

@c page
@node fd typedefs
@section Type definitions


@deftp {Struct Typedef} ccevents_fd_source_t
Type of structures representing events from file descriptors.
@end deftp


@c page
@node fd init
@section Initialisation and setup


@deftypefun void ccevents_fd_event_source_init (ccevents_fd_source_t * @var{fds}, int @var{fd})
Initialise an already allocated file descriptor event source.  Usually, we call this function only
once for each file descriptor event source.  @var{FDS} is a pointer to an already allocated fd
events source struct.  @var{FD} is the file descriptor.
@end deftypefun


@deftypefun void ccevents_fd_event_source_set (cce_location_tag_t * @var{there}, ccevents_fd_source_t * @var{fds}, ccevents_fd_source_query_fun_t * @var{query_fd_fun}, ccevents_fd_source_handler_fun_t * @var{event_handler_fun}, cevents_timeout_t @var{expiration_time}, ccevents_fd_source_expiration_handler_fun_t * @var{expiration_handler_fun})
Set up an already initialised file descriptor event source to wait for an event.  This function
starts the timeout representing the expiration time.  After the event represented by the arguments
has been served or has expired: this function can be called again for the same @var{fds} to set up
waiting for another event.  If an error occurs: raise an exception by performing a non--local exit
to @var{there}.

@var{FDS} is a pointer to an already initialised file descriptor events source.

@var{QUERY_FD_FUN} is a pointer to the function used to query the file descriptor for events.  This
function decides which events are expected: readability, writability, exceptional condition.

@var{EVENT_HANDLER_FUN} is a pointer to the function used to handle a file descriptor event.

@var{EXPIRATION_TIME} is the expiration time for the current event waiting.

@var{EXPIRATION_HANDLER_FUN} is a pointer to the function used to handle expired waiting for the
event.
@end deftypefun


To set up waiting for a readable event, in @math{5} seconds, on a pipe's file descriptor we can do
(using nested functions as allowed by a @gcc{} extension):

@smallexample
int             X[2];
cce_location_t  L;

/* X[0] is the readable end.  X[1] is the writable end. */
pipe(X);

if (cce_location(L)) @{
  cce_run_error_handlers(L);
@} else @{
  ccevents_fd_source_t fds;
  ccevents_timeout_t   expiration_time;

  void event_handler (cce_location_tag_t * there,
                      ccevents_fd_source_t * fds)
  @{
    // We should do something here.
    return;
  @}
  void expiration_handler (cce_location_tag_t * there,
                           ccevents_fd_source_t * fds)
  @{
    // We should do something here.
    return;
  @}

  ccevents_timeout_init(L, &expiration_time, 5, 0, 0);
  ccevents_fd_event_source_init(&fds, X[0]);
  ccevents_fd_event_source_set(L, &fds,
    ccevents_query_fd_readability, event_handler,
    expiration_time, expiration_handler);

  cce_run_cleanup_handlers(L);
@}
@end smallexample

@c page
@node fd query
@section Predefined query functions


@deftypefun bool ccevents_query_fd_readability (cce_location_tag_t * @var{there}, ccevents_fd_source_t * @var{fds})
Query a file descriptor for readability.  Return @true{} if the file descriptor is readable,
otherwise return @false{}.  If an error occurs: raise an exception by performing a non--local exit
to @var{there}.

Beware that some file descriptors are always readable.
@end deftypefun


@deftypefun bool ccevents_query_fd_writability (cce_location_tag_t * @var{there}, ccevents_fd_source_t * @var{fds})
Query a file descriptor for writability.  Return @true{} if the file descriptor is writable,
otherwise return @false{}.  If an error occurs: raise an exception by performing a non--local exit
to @var{there}.

Beware that some file descriptors are always writable.
@end deftypefun


@deftypefun bool ccevents_query_fd_exception (cce_location_tag_t * @var{there}, ccevents_fd_source_t * @var{fds})
Query a file descriptor for an exception; this is useful when the file descriptor is a network
socket.  Return @true{} if the file descriptor has received an exception signal, otherwise return
@false{}.  If an error occurs: raise an exception by performing a non--local exit to @var{there}.
@end deftypefun

@c page
@c ------------------------------------------------------------
@c Appendices.
@c ------------------------------------------------------------

@include lgpl-3.0.texi
@include fdl-1.3.texi

@c page
@node references
@appendix Bibliography and references


The documentation of @value{PACKAGE} is available online:

@center @value{DOCUMENTATION_URL}

@noindent
the latest release of this package can be downloaded from:

@center @value{DOWNLOAD_URL}

@noindent
development takes place at:

@center @value{GITHUB_URL}

@noindent
and as backup at:

@center @value{BITBUCKET_URL}

We can find the package  CCExceptions at:

@center @url{http://github.com/marcomaggi/ccexceptions/}

@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file

