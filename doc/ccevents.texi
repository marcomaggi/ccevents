\input texinfo.tex
@c %**start of header
@setfilename ccevents.info
@settitle CCEvents
@c %**end of header

@include version.texi
@include macros.texi

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      CCEvents

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    CCEvents

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           ccevents

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{marco.maggi-ipsu@@poste.it}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2017

@c ------------------------------------------------------------

@set GITHUB_URL                 @url{http://github.com/marcomaggi/@value{PACKAGE_NICKNAME}}
@set BITBUCKET_URL              @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}}
@set DOWNLOAD_URL               @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}/downloads}
@set DOCUMENTATION_URL          @url{http://marcomaggi.github.io/docs/@value{PACKAGE_NICKNAME}.html}

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
This document describes version @value{VERSION} of @value{PACKAGE}, a C language library
implementing an event loop.  It is written in C11 with @gcc{} extensions and it is meant to support
@gnu{}+Linux platforms.

The package is distributed under the terms of the @gnu{} Lesser General Public License (@lgpl{}).

The latest release can be downloaded from:

@center @value{DOWNLOAD_URL}

@noindent
development takes place at:

@center @value{GITHUB_URL}

@noindent
and as backup at:

@center @value{BITBUCKET_URL}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the @gnu{} Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with
Invariant Sections being ``@gnu{} Free Documentation License'' and
``@gnu{} General Public License'', no Front--Cover Texts, and no
Back--Cover Texts.  A copy of the license is included in the section
entitled ``@gnu{} Free Documentation License''.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @value{VERSION}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* ccevents: (ccevents).         CCEvents an events loop library.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* init::                        Library initialisation.
* version::                     Version functions.
* conditions::                  Exceptional condition objects.
* timevals::                    Handling time spans.
* timeouts::                    Handling event expiration times.
* sources::                     Events sources basics.
* groups::                      Groups of event sources.
* loop::                        The main events loop.
* tasks::                       Performing tasks in steps.
* timers::                      Timer events sources.
* fd::                          Events source for file descriptors.
* signals::                     Interprocess signals.

Appendices

* Package License::             GNU Lesser General Public License.
* Documentation License::       GNU Free Documentation License.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


This document describes version @value{VERSION} of @value{PACKAGE}, a C language library
implementing an event loop.  It is written in C11 with @gcc{} extensions.  The library is meant to
work on @gnu{}+Linux platforms.

There are plenty of event loop libraries already, for example Libuv:

@center @url{http://libuv.org/}

@noindent
and Libev:

@center @url{http://software.schmorp.de/pkg/libev.html}

@noindent
while @value{PACKAGE} will, maybe, never reach their level of features and reliability: it is an
interesting exercise in programming.

This package depends on the package CCExceptions, at least version 0.3, to handle exceptional
conditions; @ref{references} for details on downloading it.

@value{PACKAGE} installs the single header file @file{ccevents.h}.  All the function names in the
@api{} are prefixed with @code{cct_}; all the constant names are prefixed with @code{CCT_}; all the
type names are prefixed with @code{cct_} and suffixed with @code{_t}.

The events loop implementation is inspired by the architecture of the event loop of
@url{http://www.tcl.tk/, Tcl}; though no code comes from Tcl itself.

Notice that, before using the library, we need to call the global initialisation function
@cfunc{ccevents_init}.

@menu
* overview linking::            Linking code with the library.
@end menu

@c page
@node overview linking
@section Linking code with the library


This package installs a data file for @command{pkg-config}, so when searching for the installed
library with the @gnu{} Autotools, we can add the following macro use to @file{configure.ac}:

@example
PKG_CHECK_MODULES([CCEVENTS],[ccevents >= 0.1])
@end example

@noindent
which will set the variables @code{CCEVENTS_LIBS} and @code{CCEVENTS_CFLAGS}.  The macro
@code{PKG_CHECK_MODULES} is available in recent versions of @gnu{} Autoconf.

Alternatively we can use the raw @gnu{} Autoconf macros:

@example
AC_CHECK_LIB([ccevents],[cct_version_string],,
  [AC_MSG_FAILURE([test for CCEvents library failed])])
AC_CHECK_HEADERS([ccevents.h],,
  [AC_MSG_FAILURE([test for CCEvents header failed])])
@end example

We need to remember that client code using @value{PACKAGE}'s library must be written using the C11
language and the @gcc{} extensions enabled by @option{-fplan9-extensions}.

@c page
@node init
@chapter Library initialisation


@deftypefun void ccevents_init (void)
Initialises the internal structures of the library.  It is fine to call this function multiple
times.
@end deftypefun

@c page
@node version
@chapter Version functions


The installed libraries follow version numbering as established by the
@gnu{} Autotools.  For an explanation of interface numbers as managed by
@gnu{} Libtool @xref{Libtool versioning, interface, Libtool's versioning
system, libtool, Shared library support for @gnu{}}.


@deftypefun {const char *} cct_version_string (void)
Return a pointer to a statically allocated @asciiz{} string representing
the interface version number.
@end deftypefun


@deftypefun int cct_version_interface_current (void)
Return an integer representing the library interface current number.
@end deftypefun


@deftypefun int cct_version_interface_revision (void)
Return an integer representing the library interface current revision
number.
@end deftypefun


@deftypefun int cct_version_interface_age (void)
Return an integer representing the library interface current age.
@end deftypefun

@c page
@node conditions
@chapter Exceptional condition objects


@value{PACKAGE} makes use of the external library CCExceptions to signal exceptional conditions and
errors through non--local exits; @xref{Top, CCExceptions, CCExceptions, ccexceptions, CCExceptions}.
The functions will raise exceptional conditions with @cfunc{cce_raise} and expect the caller to
intercept them using the @code{cce_location_t} mechanics.

@menu
* conditions base::             Base exceptional conditions.
* conditions timeval::          Timeval exceptional conditions.
* conditions timeout::          Timeout exceptional conditions.
@end menu

@c page
@node conditions base
@section Base exceptional conditions


@cindex Base exceptional condition
@cindex Exceptional conditions, base


@deftp {Struct Typedef} ccevents_condition_base_descriptor_t
Type of data structure representing the base exceptional condition descriptor for all the conditions
defined by this library.  It has the following public fields:

@table @code
@item cce_condition_descriptor_t
Anonymous field representing the condition descriptor's base values.
@end table

The parent of this type descriptor is @code{cce_root_condition_descriptor} as defined by the
CCExceptions library.  @xref{conditions root, CCExceptions, CCExceptions, ccexceptions,
CCExceptions}.
@end deftp


@deftypevr {Dynamic Constant} {const ccevents_condition_base_descriptor_t *} ccevents_base_condition_descriptor
Pointer to a statically allocated exceptional condition descriptor.
@end deftypevr


@deftypefun bool ccevents_condition_is_a_base (const cce_condition_t * @var{C})
Return @true{} if @var{C} is an exceptional condition object of with type descriptor
@objtype{ccevents_condition_base_descriptor_t}; otherwise return @false{}.
@end deftypefun

@c page
@node conditions timeval
@section Timeval exceptional conditions


@menu
* timevals conditions timeval::         Timeval exceptional conditions.
* timevals conditions invalid::         Invalid timeval values.
* timevals conditions overflow::        Overflow in timeval representation.
@end menu

@c page
@node timevals conditions timeval
@subsection Timeval exceptional conditions


@cindex Timeval, exceptional condition
@cindex Exceptional conditions, timeval


@deftp {Struct Typedef} ccevents_condition_timeval_descriptor_t
Type of data structure representing a generic exceptional condition descriptor for all the
timeval--related errors; it is the base for all the timeval--related condition object types.  It has
the following public fields:

@table @code
@item cce_condition_descriptor_t
Anonymous field representing the condition descriptor's base values.
@end table

The parent of this type descriptor is the descriptor referenced by
@code{ccevents_condition_base_descriptor}.
@end deftp


@deftp {Struct Typedef} ccevents_condition_timeval_t
Type of data structure representing an exceptional condition objects for a generic timeval--related
error.  It has the following public fields:

@table @code
@item cce_condition_t
Anonymous field representing the condition object's base values.
@end table
@end deftp


@deftypevr {Constant} {const ccevents_condition_timeval_descriptor_t *} ccevents_condition_timeval_descriptor
Pointer to a statically allocated exceptional condition descriptor.
@end deftypevr


@deftypefun {const ccevents_condition_timeval_t *} ccevents_condition_timeval (void)
Return a pointer to exceptional condition object.  The returned object must be released with a
proper call to @cfunc{cce_condition_free}.
@end deftypefun


@deftypefun bool ccevents_condition_is_a_timeval (const cce_condition_t * @var{C})
Return @true{} if @var{C} is an exceptional condition object of with type descriptor
@objtype{ccevents_condition_timeval_descriptor_t}; otherwise return @false{}.
@end deftypefun


To catch this exceptional condition we can to:

@smallexample
cce_location_t        L[1];
ccevents_timeval_t    to;

if (cce_location(L)) @{
  cce_condition_t * C = cce_location_condition(L);

  if (ccevents_condition_is_a_timeval(C)) @{
    ccevents_condition_timeval_t * K = \
      (ccevents_condition_timeval_t *)C;
    do_something_with(K);
  @}
  cce_condition_free(C);
  cce_run_error_handlers(L);
@} else @{
  do_something(L);
  cce_run_cleanup_handlers(L);
@}
@end smallexample

@c page
@node timevals conditions invalid
@subsection Invalid timeval values


@cindex Invalid timeval, exceptional condition
@cindex Timeval, invalid exceptional condition
@cindex Exceptional conditions, invalid timeval


@deftp {Struct Typedef} ccevents_condition_timeval_invalid_descriptor_t
Type of data structure representing the exceptional condition descriptor for ``invalid timeval
initialisation'' errors.  It has the following public fields:

@table @code
@item cce_condition_descriptor_t
Anonymous field representing the condition descriptor's base values.
@end table

The parent of this type descriptor is the descriptor referenced by
@code{ccevents_condition_timeval_descriptor}.
@end deftp


@deftp {Struct Typedef} ccevents_condition_timeval_invalid_t
Type of data structure representing exceptional condition objects for ``invalid timeval
initialisation'' errors.  It has the following public fields:

@table @code
@item cce_condition_t
Anonymous field representing the condition object's base values.
@end table
@end deftp


@deftypevr {Constant} {const ccevents_condition_timeval_invalid_descriptor_t *} ccevents_condition_timeval_invalid_descriptor
Pointer to a statically allocated exceptional condition descriptor.
@end deftypevr


@deftypefun {const ccevents_condition_timeval_invalid_t *} ccevents_condition_timeval_invalid (void)
Return a pointer to exceptional condition object.  The returned object must be released with a
proper call to @cfunc{cce_condition_free}.
@end deftypefun


@deftypefun bool ccevents_condition_is_a_timeval_invalid (const cce_condition_t * @var{C})
Return @true{} if @var{C} is an exceptional condition object of with type descriptor
@objtype{ccevents_condition_timeval_invalid_descriptor_t}; otherwise return @false{}.
@end deftypefun


To catch this exceptional condition we can to:

@smallexample
cce_location_t        L[1];
ccevents_timeval_t    to;

if (cce_location(L)) @{
  cce_condition_t * C = cce_location_condition(L);

  if (ccevents_condition_is_a_timeval_invalid(C)) @{
    ccevents_condition_timeval_invalid_t * K = \
      (ccevents_condition_timeval_invalid_t *)C;
    do_something_with(K);
  @}
  cce_condition_free(C);
  cce_run_error_handlers(L);
@} else @{
  do_something(L);
  cce_run_cleanup_handlers(L);
@}
@end smallexample

@c page
@node timevals conditions overflow
@subsection Overflow in timeval representation


@cindex Timeval, overflow exceptional condition
@cindex Overflow in timeval, exceptional condition
@cindex Exceptional conditions, overflow in timeval


@deftp {Struct Typedef} ccevents_condition_timeval_overflow_descriptor_t
Type of data structure representing the exceptional condition descriptor for ``timeval
initialisation overflow'' errors.  It has the following public fields:

@table @code
@item cce_condition_descriptor_t
Anonymous field representing the condition descriptor's base values.
@end table

The parent of this type descriptor is the descriptor referenced by
@code{ccevents_condition_timeval_descriptor}.
@end deftp


@deftp {Struct Typedef} ccevents_condition_timeval_overflow_t
Type of data structure representing exceptional condition objects for ``timeval initialisation
overflow'' errors.  It has the following public fields:

@table @code
@item cce_condition_t
Anonymous field representing the condition object's base values.
@end table
@end deftp


@deftypevr {Constant} {const ccevents_condition_timeval_overflow_descriptor_t *} ccevents_condition_timeval_overflow_descriptor
Pointer to a statically allocated exceptional condition descriptor.
@end deftypevr


@deftypefun {const ccevents_condition_timeval_overflow_t *} ccevents_condition_timeval_overflow (void)
Return a pointer to exceptional condition object.  The returned object must be released with a
proper call to @cfunc{cce_condition_free}.
@end deftypefun


@deftypefun bool ccevents_condition_is_a_timeval_overflow (const cce_condition_t * @var{C})
Return @true{} if @var{C} is an exceptional condition object of with type descriptor
@objtype{ccevents_condition_timeval_overflow_descriptor_t}; otherwise return @false{}.
@end deftypefun


To catch this exceptional condition we can to:

@smallexample
cce_location_t        L[1];
ccevents_timeval_t    to;

if (cce_location(L)) @{
  cce_condition_t * C = cce_location_condition(L);

  if (ccevents_condition_is_a_timeval_overflow(C)) @{
    ccevents_condition_timeval_overflow_t * K = \
      (ccevents_condition_timeval_overflow_t *)C;
    do_something_with(K);
  @}
  cce_condition_free(C);
  cce_run_error_handlers(L);
@} else @{
  do_something(L);
  cce_run_cleanup_handlers(L);
@}
@end smallexample

@c page
@node conditions timeout
@section Timeout exceptional conditions


@menu
* timeouts conditions invalid::         Invalid timeout values.
* timeouts conditions overflow::        Overflow in timeout representation.
@end menu

@c page
@node timeouts conditions invalid
@subsection Invalid timeout values


@deftp {Struct Typedef} ccevents_condition_descriptor_timeout_invalid_t
Type of data structure representing the exceptional condition descriptor for ``invalid timeout
initialisation'' errors.  It has the following public fields:

@table @code
@item cce_condition_descriptor_t
Anonymous field representing the condition descriptor's base values.
@end table

The parent of this type descriptor is the descriptor referenced by @code{ccevents_base_condition_descriptor}.
@end deftp


@deftp {Struct Typedef} ccevents_condition_timeout_invalid_t
Type of data structure representing exceptional condition objects for ``invalid timeout
initialisation'' errors.  It has the following public fields:

@table @code
@item cce_condition_t
Anonymous field representing the condition object's base values.
@end table
@end deftp


@deftypevr {Constant} {const ccevents_condition_descriptor_timeout_invalid_t *} ccevents_condition_timeout_invalid_descriptor
Pointer to a statically allocated exceptional condition descriptor.
@end deftypevr


@deftypefun {const ccevents_condition_timeout_invalid_t *} ccevents_condition_timeout_invalid (void)
Return a pointer to exceptional condition object.  The returned object must be released with a
proper call to @cfunc{cce_condition_free}.
@end deftypefun


@deftypefun bool ccevents_condition_is_a_timeout_invalid (const cce_condition_t * @var{C})
Return @true{} if @var{C} is an exceptional condition object of with type descriptor
@objtype{ccevents_condition_descriptor_timeout_invalid_t}; otherwise return @false{}.
@end deftypefun


To catch this exceptional condition we can to:

@smallexample
cce_location_t        L[1];
ccevents_timeout_t    to;

if (cce_location(L)) @{
  cce_condition_t * C = cce_location_condition(L);

  if (ccevents_condition_is_a_timeval_invalid(C)) @{
    ccevents_condition_timeout_invalid_t * K = \
      (ccevents_condition_timeout_invalid_t *)C;
    do_something_with(K);
  @}
  cce_condition_free(C);
  cce_run_error_handlers(L);
@} else @{
  do_something(L);
  cce_run_cleanup_handlers(L);
@}
@end smallexample

@c page
@node timeouts conditions overflow
@subsection Overflow in timeout representation


@deftp {Struct Typedef} ccevents_condition_descriptor_timeout_overflow_t
Type of data structure representing the exceptional condition descriptor for ``timeout
initialisation overflow'' errors.  It has the following public fields:

@table @code
@item cce_condition_descriptor_t
Anonymous field representing the condition descriptor's base values.
@end table

The parent of this type descriptor is the descriptor referenced by
@code{ccevents_base_condition_descriptor}.
@end deftp


@deftp {Struct Typedef} ccevents_condition_timeout_overflow_t
Type of data structure representing exceptional condition objects for ``timeout initialisation
overflow'' errors.  It has the following public fields:

@table @code
@item cce_condition_t
Anonymous field representing the condition object's base values.
@end table
@end deftp


@deftypevr {Constant} {const ccevents_condition_descriptor_timeout_overflow_t *} ccevents_condition_timeout_overflow_descriptor
Pointer to a statically allocated exceptional condition descriptor.
@end deftypevr


@deftypefun {const ccevents_condition_timeout_overflow_t *} ccevents_condition_timeout_overflow (void)
Return a pointer to exceptional condition object.  The returned object must be released with a
proper call to @cfunc{cce_condition_free}.
@end deftypefun


@deftypefun bool ccevents_condition_is_a_timeout_overflow (const cce_condition_t * @var{C})
Return @true{} if @var{C} is an exceptional condition object of with type descriptor
@objtype{ccevents_condition_descriptor_timeout_overflow_t}; otherwise return @false{}.
@end deftypefun


To catch this exceptional condition we can to:

@smallexample
cce_location_t        L[1];
ccevents_timeout_t    to;

if (cce_location(L)) @{
  cce_condition_t * C = cce_location_condition(L);

  if (ccevents_condition_is_a_timeout_overflow(C)) @{
    ccevents_condition_timeout_overflow_t * K = \
      (ccevents_condition_timeout_overflow_t *)C;
    do_something_with(K);
  @}
  cce_condition_free(C);
  cce_run_error_handlers(L);
@} else @{
  do_something(L);
  cce_run_cleanup_handlers(L);
@}
@end smallexample

@c page
@node timevals
@chapter Handling time spans


It is typical for a C language system function, under a Unix--like system, to require a @code{struct
timeval} value to represent a time span; @value{PACKAGE} implements an @api{} to handle such
objects.

The @api{} is peculiar because often it requires the whole data structure to passed by value, rather
than using a pointer to structure as is usually the case.


@deftp {Struct Typedef} ccevents_timeval_t
An alias for @objtype{struct timeval} used to represent normalised values.  A normalised value is
such that the fields @code{tv_sec} and @code{tv_usec} obey the following constraints:

@example
0 <= tv_sec  <= LONG_MAX
0 <= tv_usec <= 999999
@end example

This type has the following public fields:

@table @code
@item struct timeval;
An anonymous field.
@end table
@end deftp


@deftypefun ccevents_timeval_t ccevents_timeval_init (cce_location_t * there, long @var{seconds}, long @var{microseconds})
Build and return a timeval structure initialised and normalised with the given arguments.  If an
error occurs while normalising: an exception is raised by performing a non--local exit to
@var{there}.

The argument @var{seconds} is meant to be in the range @samp{[0, LONG_MAX]}.  The argument
@var{microseconds} is meant to be in the range @samp{[LONG_MIN, LONG_MAX]}.
@end deftypefun


@deftypefun ccevents_timeval_t ccevents_timeval_normalise (cce_location_t * @var{there}, struct timeval @var{T})
Build and return a timeval structure initialised and normalised with the given arguments.  If an
error occurs while normalising: an exception is raised by performing a non--local exit to
@var{there}.

The field @code{tv_sec} of @var{T} is meant to be in the range @samp{[0, LONG_MAX]}.  The field
@code{tv_usec} of @var{T} is meant to be in the range @samp{[LONG_MIN, LONG_MAX]}.
@end deftypefun


@deftypefun ccevents_timeval_t ccevents_timeval_add (cce_location_t * @var{there}, ccevents_timeval_t @var{A}, ccevents_timeval_t @var{B})
Add the two timeval values @var{A} and @var{B} and return a normalised timeval value.  If an error
occurs while adding or normalising: an exception is raised by performing a non--local exit to
@var{there}.
@end deftypefun


@deftypefun ccevents_timeval_t ccevents_timeval_sub (cce_location_t * @var{there}, ccevents_timeval_t @var{A}, ccevents_timeval_t @var{B})
Subtract @var{B} from @var{A} and return a normalised timeval value representing the difference.  If
an error occurs while subtracting or normalising: an exception is raised by performing a non--local
exit to @var{there}.
@end deftypefun


@deftypefun int ccevents_timeval_compare (ccevents_timeval_t @var{A}, ccevents_timeval_t @var{B})
Compare the timeval values @var{A} and @var{B}.  Return:

@table @code
@item 0
If @var{A} is equal to @var{B}.

@item +1
If @var{A} is greater than @var{B}.

@item -1
If @var{A} is less than @var{B}.
@end table
@end deftypefun


@c page
@node timeouts
@chapter Handling event expiration times


This module implements ``polling timeouts''.

@menu
* timeouts typedefs::           Type definitions.
* timeouts init::               Constructors.
* timeouts getters::            Getter functions.
* timeouts predicates::         Predicates.
* timeouts comparison::         Comparison.
* timeouts operations::         Operations.
@end menu

@c page
@node timeouts typedefs
@section Type definitions


@deftp {Struct Typedef} ccevents_timeout_t
Represents a time span from a point in time towards the future.  It is meant to be used to signal
that an event has not happended in a fixed amount of time.

Holds values for seconds, milliseconds and microseconds as @code{long int}.  The number of seconds
can only be zero or positive; the numbers of milliseconds and microseconds are normalised by
@cfunc{ccevents_timeout_init} to the range @code{[0, 999]}; the normalisation process can lead to an
overflow, which is signalled by raising an exception.

The maximum representable time span is: @code{LONG_MAX-1} seconds, @code{999} milliseconds,
@code{999} microseconds.  When the number of seconds is set to @code{LONG_MAX}: the time span is
interpreted as ``infinite'', the timeout will never expire.

An instance of this structure type is also an instance of @code{struct timeval}.

To copy a timeout data structure we can use the C language @code{=} operator.
@end deftp

@c page
@node timeouts init
@section Constructors


@deftypefun void ccevents_timeout_init (cce_location_t * @var{there}, ccevents_timeout_t * @var{to}, long @var{seconds}, long @var{milliseconds}, long @var{microseconds})
Initialise an already allocated timeout structure.  The arguments @var{seconds}, @var{milliseconds}
and @var{microseconds} represent a time span towards the future:

@table @var
@item seconds
It is a count of seconds; it must be in the range @code{[0, LONG_MAX]}.  It is normalised to the
range @code{[0, LONG_MAX]}.

@item milliseconds
It is a count of milliseconds; it must be in the range @code{[LONG_MIN, LONG_MAX]}.  It is
normalised to the range @code{[0, 999]}.

@item microseconds
It is a count of microseconds; it must be in the range @code{[LONG_MIN, LONG_MAX]}.  It is
normalised to the range @code{[0, 999]}.
@end table

If an error occurs while normalising the given time span specification: raise an exception by
performing a non--local exit to @var{there}.
@end deftypefun


@deftypevr {Dynamic Constant} {const ccevents_timeout_t *} CCEVENTS_TIMEOUT_NEVER
Pointer to a constant, statically allocated instance of @objtype{ccevents_timeout_t} representing a
timeout that never expires.
@end deftypevr


@deftypevr {Dynamic Constant} {const ccevents_timeout_t *} CCEVENTS_TIMEOUT_NOW
Pointer to a constant, statically allocated instance of @objtype{ccevents_timeout_t} representing a
timeout that expires immediately.
@end deftypevr

@c page
@node timeouts getters
@section Getter functions


@deftypefn {Inline Function} long ccevents_timeout_seconds (const ccevents_timeout_t * @var{to})
Return the current number of seconds.  The value is in the range @code{[0, LONG_MAX]}.
@end deftypefn


@deftypefn {Inline Function} long ccevents_timeout_milliseconds (const ccevents_timeout_t * @var{to})
Return the current number of milliseconds.  The value is in the range @code{[0, 999]}.
@end deftypefn


@deftypefn {Inline Function} long ccevents_timeout_microseconds (const ccevents_timeout_t * @var{to})
Return the current number of microseconds.  The value is in the range @code{[0, 999]}.
@end deftypefn


@deftypefun ccevents_timeval_t ccevents_timeout_time_span (const ccevents_timeout_t * @var{to})
Return a timeval structure representing the current time span referenced by @var{to}.  The value in
the field @code{tv_sec} is in the range @code{[0, LONG_MAX]}, while the value in the field
@code{tv_usec} is in the range @code{[0, 999999]}.
@end deftypefun


@deftypefun ccevents_timeval_t ccevents_timeout_time (const ccevents_timeout_t * @var{to})
Return a timeval structure representing the current expiration absolute time; the returned value is
meaningful only if the timeout has been started.  The value in the field @code{tv_sec} is in the
range @code{[0, LONG_MAX]}, while the value in the field @code{tv_usec} is in the range @code{[0,
999999]}.
@end deftypefun

@c page
@node timeouts predicates
@section Predicates


@deftypefun bool ccevents_timeout_infinite_time_span (const ccevents_timeout_t * @var{to})
Return true if @var{to} represents an ``infinite'' time span: one for which
@cfunc{ccevents_timeout_expired} will never return true.
@end deftypefun


@deftypefun bool ccevents_timeout_expired (const ccevents_timeout_t * @var{to})
Acquire the current time and compare it with the expiration time.  Return true if the timeout has
expired; otherwise return false.
@end deftypefun

@c page
@node timeouts comparison
@section Comparison functions


@deftypefun int ccevents_timeout_compare_time_span (const ccevents_timeout_t * @var{A}, const ccevents_timeout_t * @var{B})
Compare the time spans of two timeouts; return: @code{-1} if @code{@var{A} < @var{B}}, @code{0} if
@code{@var{A} == @var{B}}, @code{+1} if @code{@var{A} > @var{B}}.
@end deftypefun


@deftypefun int ccevents_timeout_compare_expiration_time (const ccevents_timeout_t * @var{A}, const ccevents_timeout_t * @var{B})
Compare the expiration times of two timeouts; return: @code{-1} if @code{@var{A} < @var{B}}, @code{0}
if @code{@var{A} == @var{B}}, @code{+1} if @code{@var{A} > @var{B}}.
@end deftypefun

@c page
@node timeouts operations
@section Operations


@deftypefun void ccevents_timeout_start (cce_location_t * @var{there}, ccevents_timeout_t * @var{to})
Start the timer associated to the already initialised @var{to} object: acquire the current absolute
time and compute the time instant that will expire the timeout.  The expiration time is stored in
the structure referenced by @var{to}.  As a special case: if the time span is infinite, the
expiration time is set to: @code{LONG_MAX} seconds; this should guarantee that @var{to} will never
expire.  If an error occurs: raise an exception by performing a non--local exit to @var{there}.
@end deftypefun


@deftypefun void ccevents_timeout_reset (ccevents_timeout_t * @var{to})
Reset a timeout, ``stop'' the timer.  The expiration time is set to a value meaning infinite
expiration time.
@end deftypefun

@c page
@node sources
@chapter Events sources basics


Events sources are the basic building blocks of events loops managed by @value{PACKAGE}.  Events
always come from a ``source'', be it an operating system timer, a single file descriptor, a group of
network sockets representing connections to a server, a file system change monitored with the
@samp{inotify} @api{}, et cetera.

@menu
* sources typedefs::            Type definitions.
* sources api::                 Application programming interface.
* sources example::             Example of events source definition.
@end menu

@c page
@node sources typedefs
@section Type definitions


@value{PACKAGE} defines some predefined events source types, and we can define new ones.  All of
them are subtypes of @objtype{ccevents_source_t}.


@deftp {Struct Typedef} ccevents_source_t
Base structure for all the events sources.  Every events source is meant to be associated to a
group, @ref{groups, Groups of event sources}.

Every events source contains an expiration timeout; it is meant to be used in one of two ways:

@itemize
@item
The next event from the source must be served before the timeout expires, otherwise special handling
is triggered.

@item
The whole use of a source must be completed before the timeout expires, otherwise special handling
is triggered.
@end itemize

@noindent
By default, the timeout is set to ``never expire'' and an internal expiration handler that does
nothing is registered in the source structure.
@end deftp


@deftypefn {Function Type} bool ccevents_source_event_inquirer_fun_t (cce_location_t * @var{there}, ccevents_group_t * @var{grp}, ccevents_source_t * @var{src})
Function prototype of event inquiry functions.  A function of this type is meant to query the event
source referenced by @var{src} to determine if an event is pending or not:

@itemize
@item
If an event is pending: it must return @true{}.

@item
If no event is pending: it must return @false{}.

@item
If inquiring for events raises an exceptional condition: a non--local exit must be performed by
jumping to @var{there}.
@end itemize

The group referenced by @var{grp} must be the one to which @var{src} is associated.  When this
function is called @var{src} must have been dequeued from @var{grp}: it is up to the inquirer, the
event handler, or an exceptional condition handler, to re--enqueue @var{src} into @var{grp} or not.
Usually, if no event is pending: the inquirer function re--enqueues @var{src} into @var{grp},
because no other function will be applied to @var{src}.
@end deftypefn


@deftypefn {Function Type} void ccevents_source_event_handler_fun_t (cce_location_t * @var{there}, ccevents_group_t * @var{grp}, ccevents_source_t * @var{src})
Function prototype of event handler functions.  A function of this type is meant to serve a pending
event on the event source referenced by @var{src}.  If serving the event raises an exceptional
condition: a non--local exit must be performed by jumping to @var{there}.

Functions of this type are meant to be called only after the event inquirer function, applied to the
same operands, returned @true{}.

The group referenced by @var{grp} must be the one to which @var{src} is associated.  When this
function is called @var{src} must have been dequeued from @var{grp}: it is up to the handler, or an
exceptional condition handler, to re--enqueue @var{src} into @var{grp} or not, selecting the
appropriate event handler.

Typically, an events source has multiple event handlers that are selected in turn; after an event
handler has served an event (say: by reading data from a network socket), it re--enqueues the source
in the group selecting another event handler (say: to write data to the same network socket).
@end deftypefn


@deftypefn {Function Type} void ccevents_source_expiration_handler_fun_t (cce_location_t * @var{there}, ccevents_group_t * @var{grp}, ccevents_source_t * @var{src})
Function prototype of expiration handler functions.  A function of this type is meant to react to a
timeout expiration associated to the event source referenced by @var{src}.  If handling the timeout
raises an exceptional condition: a non--local exit must be performed by jumping to @var{there}.

The group referenced by @var{grp} must be the one to which @var{src} is associated.  When this
function is called @var{src} must have been dequeued from @var{grp}: it is up to the handler, or an
exceptional condition handler, to re--enqueue @var{src} into @var{grp} or not.
@end deftypefn


@deftp {Struct Typedef} ccevents_source_vtable_t
Structure type representing a table of methods acting on an events source.  Every subtype of
@objtype{ccevents_source_t} must define an instance of this table and use it in a call to
@cfunc{ccevents_source_init}.  It has the following public fields:

@table @code
@item ccevents_source_event_inquirer_fun_t * event_inquirer
Pointer to the event inquirer function.  It is called to determine if the events source has a
pending event or not.

@item ccevents_source_event_handler_fun_t * event_handler
Pointer to the event handler function.  It is called when to serve a pending event.
@end table

See @cfunc{ccevents_source_do_one_event} for details on how these functions are used.
@end deftp

@c page
@node sources api
@section Application programming interface


@deftypefun void ccevents_source_init (ccevents_source_t * @var{src}, const ccevents_source_vtable_t * @var{vtable})
Initialise an already allocated events source structure referenced by @var{src}.  This function is
typically invoked by the initialisation function of the events source subtype.  Register @var{vtable}
as table of function pointers acting on this specific events source type.

Set the event expiration timeout to never: if this setting is not overridden with
@cfunc{ccevents_source_set_timeout}, waiting for events on this source will never expire.
@end deftypefun


@deftypefun void ccevents_source_set_timeout (ccevents_source_t * @var{src}, ccevents_timeout_t @var{expiration_time}, ccevents_source_expiration_handler_fun_t * @var{expiration_handler})
Setup a new expiration timeout.  This function does @strong{not} start the timeout, this operation
is performed by @cfunc{ccevents_source_set}.
@end deftypefun


@deftypefun void ccevents_source_set (cce_location_t * @var{there}, ccevents_source_t * @var{src})
Start the waiting for the next event.  The expiration timeout is started by registering the current
calendar time.  If an exceptional condition is raised: a non--local exit is performed by jumping to
@var{there}.  This function is typically invoked by the set function of the events source subtype.
@end deftypefun


@deftypefun bool ccevents_source_do_one_event (cce_location_t * @var{there}, ccevents_group_t * @var{grp}, ccevents_source_t * @var{src})
Consume one event from the events source referenced by @var{src} if there is one.  Return @true{} if
one event was served or the timeout expired; otherwise @false{}.  If an exceptional condition is
raised: a non--local exit is performed by jumping to @var{there}.

The group referenced by @var{grp} must be the one to which @var{src} is associated.  When this
function is called @var{src} must have been dequeued from @var{grp}: it is up to the handlers, or an
exceptional condition handler, to re--enqueue @var{src} into @var{grp} or not.

Serving an event is done with the following steps:

@enumerate
@item
Check the expiration timeout: if the timeout has expired, call the expiration handler and return
@true{}.  If the expiration handler function raises an exceptional condition: a non--local exit is
performed by jumping to @var{there}.

@item
Query the events source for the availability of an event.  If no event is pending: return @false{}.
If the event inquiry function raises an exceptional condition: a non--local exit is performed by
jumping to @var{there}.

@item
If an event is pending: call the event handler function and return @true{}.  If the event handler
function raises an exceptional condition: a non--local exit is performed by jumping to @var{there}.
@end enumerate
@end deftypefun


@deftypefun bool ccevents_source_is_enqueued (const ccevents_source_t * @var{src})
Return @true{} if the source is enqueued in a group, otherwise return @false{}.
@end deftypefun


@deftypefun bool ccevents_source_dummy_event_inquirer (cce_location_t * @var{there}, ccevents_group_t * @var{grp}, ccevents_source_t * @var{src})
A dummy event inquirer function: re--enqueue @var{src} into @var{grp} and return @false{}.
@end deftypefun


@deftypefun void ccevents_source_dummy_event_handler (cce_location_t * @var{there}, ccevents_group_t * @var{grp}, ccevents_source_t * @var{src})
A dummy event handler function: does nothing.
@end deftypefun

@c page
@node sources example
@section Example of events source definition


To understand how events sources are subtyped and used, let's look at a possible implementation of
the task events source defined by @value{PACKAGE}:

@smallexample
typedef struct ccevents_task_source_t @{
  ccevents_source_t;
  ccevents_source_event_inquirer_fun_t * event_inquirer;
  ccevents_source_event_handler_fun_t  * event_handler;
@} ccevents_task_source_t;

static bool
method_event_inquirer (cce_location_t * there,
                       ccevents_group_t   * grp,
                       ccevents_source_t  * src)
@{
  ccevents_task_source_t * tksrc = (ccevents_task_source_t *) src;
  return tksrc->event_inquirer(there, grp, tksrc);
@}

static void
method_event_handler (cce_location_t * there,
                      ccevents_group_t   * grp,
                      ccevents_source_t  * src)
@{
  ccevents_task_source_t * tksrc = (ccevents_task_source_t *) src;
  return tksrc->event_handler(there, grp, tksrc);
@}

static const ccevents_source_vtable_t methods_table = @{
  .event_inquirer       = method_event_inquirer,
  .event_handler        = method_event_handler,
@};

void
ccevents_task_source_init (ccevents_task_source_t * tksrc)
@{
  ccevents_source_init(tksrc, &methods_table);
@}

void
ccevents_task_source_set (cce_location_t * there,
    ccevents_task_source_t               * tksrc,
    ccevents_source_event_inquirer_fun_t * event_inquirer,
    ccevents_source_event_handler_fun_t  * event_handler)
@{
  ccevents_source_set(there, tksrc);
  tksrc->event_inquirer = event_inquirer;
  tksrc->event_handler  = event_handler;
@}
@end smallexample

@noindent
this module is used as follows:

@smallexample
#include <ccevents.h>

bool
event_inquirer (cce_location_t * there,
                ccevents_group_t * grp, ccevents_source_t * src)
@{
  // The next step is always ready to be executed.
  return true;
@}
void
expiration_handler (cce_location_t * there,
                    ccevents_group_t * grp, ccevents_source_t * src)
@{
  // Handle the expiration here.
@}

void
step1 (cce_location_t * there,
       ccevents_group_t * grp, ccevents_source_t * src)
@{
  ccevents_task_source_t *    tksrc = (ccevents_task_source_t *) src;
  // Perform the first step here.
  ccevents_task_source_set(there, tksrc, event_inquirer, step2);
  ccevents_group_enqueue_source(grp, tksrc);
@}
void
step2 (cce_location_t * there,
       ccevents_group_t * grp, ccevents_source_t * src)
@{
  ccevents_task_source_t *    tksrc = (ccevents_task_source_t *) src;
  // Perform the second step here.
  ccevents_task_source_set(there, tksrc, event_inquirer, step3);
  ccevents_group_enqueue_source(grp, tksrc);
@}
void
step3 (cce_location_t * there,
       ccevents_group_t * grp, ccevents_source_t * src)
@{
  // Perform the third step here.
@}

void
doit (void)
@{
  ccevents_group_t              grp[1];
  ccevents_task_source_t        tksrc[1];
  cce_location_t                L[1];

  if (cce_location(L)) @{
    cce_run_error_handlers(L);
    cce_condition_free(cce_location_condition(L));
  @} else @{
    ccevents_task_source_init(tksrc);
    ccevents_task_source_set(L, tksrc, event_inquirer, step1);
    ccevents_group_init(grp);
    ccevents_group_enqueue_source(grp, tksrc);
    ccevents_group_enter(grp, 3);
    cce_run_cleanup_handlers(L);
  @}
@}
@end smallexample

@c page
@node groups
@chapter Groups of event sources


Groups are collection of event sources that must be queried for pending events with the same
priority.  Multiple groups are used to establish a priority order between sets of sources.  Events
from higher priority groups should be served before events from lower priority groups.  To avoid
starving lower groups: every, say, @math{10} events served from a higher group, @math{1} event is
served from a lower group.


@deftp {Struct Typedef} ccevents_group_t
Type of groups of event sources.

Instances of this type must be initialised with a call to @cfunc{ccevents_group_init} applied to an
already allocated data structure.

Instances of this type must be finalised by first dequeuing all the sources with
@cfunc{ccevents_group_dequeue_source}, and then, if needed, by releasing the memory allocated for
the data structure.
@end deftp


@deftypefun void ccevents_group_init (ccevents_group_t * @var{grp}, size_t @var{served_events_watermark})
Initialise an already allocated group structure.  The internal queue of event sources is initialised
to empty.  The number of served events for each call to @cfunc{ccevents_group_enter} is set to
@var{served_events_watermark}.
@end deftypefun


@deftypefun bool ccevents_group_queue_is_not_empty (const ccevents_group_t * @var{grp})
Return @true{} if the group has at least one event source in the queue; otherwise return @false{}.
@end deftypefun


@deftypefun size_t ccevents_group_number_of_sources (const ccevents_group_t * @var{grp})
Return the number of events sources enqueued in @var{grp}.
@end deftypefun


@deftypefun bool ccevents_group_contains_source (const ccevents_group_t * @var{grp}, const ccevents_source_t * @var{src})
Return @true{} if the source @var{src} is enqueued in the group @var{grp}; otherwise return
@false{}.
@end deftypefun


@deftypefun void ccevents_group_enqueue_source (ccevents_group_t * @var{grp}, ccevents_source_t * @var{src})
Enqueue the events source @var{src} in the group @var{grp}.
@end deftypefun


@deftypefun {ccevents_source_t *} ccevents_group_dequeue_source (ccevents_group_t * @var{grp})
Dequeue an events source from the group @var{grp} and return it.  Return @cnull{} if the group is
empty.
@end deftypefun


@deftypefun void ccevents_group_remove_source (ccevents_group_t * @var{grp}, ccevents_source_t * @var{src})
Remove the source referenced by @var{src} from the group referenced by @var{grp}.  If @var{src} is
not associated to @var{grp}: the result is unspecified.
@end deftypefun


@deftypefun bool ccevents_group_run_do_one_event (ccevents_group_t * @var{grp})
Dequeue the next events source in @var{grp} and serve one event from it.  Return @true{} if, after
serving one event: more event sources are waiting to be served; otherwise return @false{} if no more
events sources are waiting.
@end deftypefun


@deftypefun void ccevents_group_enter (ccevents_group_t * @var{grp})
Enter the loop for this group and serve events until: the number of served events reaches the
configured watermark level; no more events sources are enqueued; a request to exit is posted with
@cfunc{ccevents_group_post_request_to_leave_asap}.
@end deftypefun


@deftypefun void ccevents_group_post_request_to_leave_asap (ccevents_group_t * @var{grp})
Post a request to exit as soon as possible the loop for this group.  This function is meant to be
called by an event handler to cause a premature return from a call to @cfunc{ccevents_group_enter}.
@end deftypefun

@c page
@node loop
@chapter The main events loop


The main events loop contains references to groups of events sources that must be served.  Usage
example:

@example
#include <ccevents.h>

ccevents_loop_t         loop[1];
ccevents_group_t        grpA[1], grpB[1];

ccevents_loop_init(loop);
ccevents_group_init(grpA, 10);
ccevents_group_init(grpB, 5);

/* Here we should add events sources to the groups. */

ccevents_loop_enqueue_group(loop, grpA);
ccevents_loop_enqueue_group(loop, grpB);

ccevents_group_enter(loop);

while (ccevents_loop_queue_is_not_empty(loop))
@{
  ccevents_group_t *    grp;
  grp = ccevents_loop_dequeue_group(loop);
  /* Here we should finalise the group. */
@}
@end example


@deftp {Struct Typedef} ccevents_loop_t
Type of data structures representing a main events loop.

Instances of this type must be initialised with a call to @cfunc{ccevents_group_init} applied to an
already allocated data structure.

Instances of this type must be finalised by first dequeuing all the groups with
@cfunc{ccevents_group_dequeue_group}, and then, if needed, by releasing the memory allocated for the
data structure.
@end deftp


@deftypefun void ccevents_loop_init (ccevents_loop_t * @var{loop})
Initialise an already allocated loop structure.  The internal queue of groups is initialised to
empty.
@end deftypefun


@deftypefun bool ccevents_loop_queue_is_not_empty (const ccevents_loop_t * @var{loop})
Return @true{} if this loop has at least one group in the queue; otherwise return @false{}.
@end deftypefun


@deftypefun size_t ccevents_loop_number_of_groups (const ccevents_loop_t * @var{loop})
Return the number of groups enqueued in @var{loop}.
@end deftypefun


@deftypefun bool ccevents_loop_contains_group (const ccevents_loop_t * @var{loop}, const ccevents_group_t * @var{grp})
Return @true{} if the group @var{grp} is enqueued in the loop @var{loop}; otherwise return @false{}.
@end deftypefun


@deftypefun void ccevents_loop_enqueue_group (ccevents_loop_t * @var{loop}, ccevents_group_t * @var{grp})
Enqueue the group @var{grp} in the loop @var{loop}.
@end deftypefun


@deftypefun {ccevents_group_t *} ccevents_loop_dequeue_group (ccevents_loop_t * @var{loop})
Dequeue a group from @var{loop} and return it.  Return @cnull{} if the loop is empty.
@end deftypefun


@deftypefun void ccevents_loop_remove_group (ccevents_loop_t * @var{loop}, ccevents_group_t * @var{grp})
Remove the group referenced by @var{grp} from the loop referenced by @var{loop}.  If @var{grp} is
not associated to @var{loop}: the result is unspecified.
@end deftypefun


@deftypefun void ccevents_loop_enter (ccevents_loop_t * @var{loop})
Enter the loop and serve events until: no more groups are enqueued; a request to exit is posted with
@cfunc{ccevents_loop_post_request_to_leave_asap}.
@end deftypefun


@deftypefun void ccevents_loop_post_request_to_leave_asap (ccevents_loop_t * @var{loop})
Post a request to exit as soon as possible the loop.  This function is meant to be called by an
event handler to cause a premature return from a call to @cfunc{ccevents_loop_enter}.
@end deftypefun

@c page
@node tasks
@chapter Performing tasks in steps


The task source is the most basic events source defined by @value{PACKAGE}.


@deftp {Struct Typedef} ccevents_task_source_t
Type of task events source.  It is ``derived'' from @objtype{ccevents_source_t}, meaning that the
first field of @objtype{ccevents_task_source_t} is an anonymous field of type
@objtype{ccevents_source_t}.
@end deftp


@deftypefun void ccevents_task_source_init (ccevents_task_source_t * @var{src})
Initialise an already allocated task source structure referenced by @var{src}.  Apply
@cfunc{ccevents_source_init} to @var{src}.
@end deftypefun


@deftypefun void ccevents_task_source_set (cce_location_t * @var{there}, ccevents_task_source_t * @var{tksrc}, ccevents_source_event_inquirer_fun_t * @var{event_inquirer}, ccevents_source_event_handler_fun_t * @var{event_handler})
Start the next waiting for events in @var{tksrc}.  Apply @cfunc{ccevents_source_set} to @var{src}.
If an exceptional condition is raised: perform a non--local exit by jumping to @var{there}.

The @var{event_handler} is meant perform a task step and to call this function again to select the
next step.
@end deftypefun


The task source is meant to be used as follows:

@smallexample
#include <ccevents.h>

bool
event_inquirer (cce_location_t * there,
                ccevents_group_t * grp, ccevents_source_t * src)
@{
  // The next step is always ready to be executed.
  return true;
@}
void
expiration_handler (cce_location_t * there,
                    ccevents_group_t * grp, ccevents_source_t * src)
@{
  // Handle the expiration here.
@}

void
step1 (cce_location_t * there,
       ccevents_group_t * grp, ccevents_source_t * src)
@{
  ccevents_task_source_t *    tksrc = (ccevents_task_source_t *) src;
  // Perform the first step here.
  ccevents_task_source_set(there, tksrc, event_inquirer, step2);
  ccevents_group_enqueue_source(grp, tksrc);
@}
void
step2 (cce_location_t * there,
       ccevents_group_t * grp, ccevents_source_t * src)
@{
  ccevents_task_source_t *    tksrc = (ccevents_task_source_t *) src;
  // Perform the second step here.
  ccevents_task_source_set(there, tksrc, event_inquirer, step3);
  ccevents_group_enqueue_source(grp, tksrc);
@}
void
step3 (cce_location_t * there,
       ccevents_group_t * grp, ccevents_source_t * src)
@{
  // Perform the third step here.
@}

void
doit (void)
@{
  ccevents_group_t              grp[1];
  ccevents_task_source_t        tksrc[1];
  cce_location_t                L[1];

  if (cce_location(L)) @{
    cce_run_error_handlers(L);
    cce_condition_free(cce_location_condition(L));
  @} else @{
    ccevents_task_source_init(tksrc);
    ccevents_task_source_set(L, tksrc, event_inquirer, step1);
    ccevents_group_init(grp);
    ccevents_group_enqueue_source(grp, tksrc);
    ccevents_group_enter(grp, 3);
    cce_run_cleanup_handlers(L);
  @}
@}
@end smallexample

@c page
@node timers
@chapter Timer events sources


The timer events sources defined by this @api{} trigger an event whenever the event loop examines
the timer events source structure; there is no special mechanism to interrupt the process execution
and signal a timer (this @api{} does not use @posix{}'s @cfunc{timer_create}).


@deftp {Struct Typedef} ccevents_timer_source_t
This is a very simple source that exploits the timeout mechanism to implement a timer.  The timer
calendar time and the expiration handler are selected with @cfunc{ccevents_source_set_timeout}.
@end deftp


@deftypefun void ccevents_timer_source_init (ccevents_timer_source_t * @var{timsrc})
Initialise an already allocated source structure.  This function applies
@cfunc{ccevents_source_init} to @var{timsrc}.
@end deftypefun


@deftypefun void ccevents_timer_source_set (cce_location_t * @var{there}, ccevents_timer_source_t * @var{timsrc})
Start the timer for the source referenced by @var{timsrc}.  This function applies
@cfunc{ccevents_source_set} to @var{there} and @var{timsrc}.  If an exceptional condition is raised:
perform a non--local exit by jumping to @var{there}.
@end deftypefun

@c page
@node fd
@chapter Event source for file descriptors


The file descriptor events source @api{} implements an event source associated to a single file
descriptor.  This @api{} is @strong{not} suitable for server programs that need to serve a ``high''
number of connections per second, but it should be easy to use, for example, to organise
communication between processes through pipes or socket pairs.

@menu
* fd typedefs::                 Type definitions.
* fd init::                     Initialisation and setup.
* fd query::                    Predefined query functions.
@end menu

@c page
@node fd typedefs
@section Type definitions


@deftp {Struct Typedef} ccevents_fd_source_t
Type of structures representing events from file descriptors.

This structure type is ``derived'' from @objtype{ccevents_source_t}, meaning that the first field is
anonymous of type @objtype{ccevents_source_t}.
@end deftp


@c page
@node fd init
@section Initialisation and setup


@deftypefun void ccevents_fd_event_source_init (ccevents_fd_source_t * @var{fdsrc}, int @var{fd})
Initialise an already allocated file descriptor events source.  Usually, we call this function only
once for each file descriptor events source.  @var{fdsrc} is a pointer to an already allocated
structure.  @var{FD} is the file descriptor.
@end deftypefun


@deftypefun void ccevents_fd_event_source_set (cce_location_t * @var{there}, ccevents_fd_source_t * @var{fdsrc}, ccevents_source_event_inquirer_fun_t * @var{event_inquirer}, ccevents_source_event_handler_fun_t * @var{event_handler})
Set up an already initialised file descriptor events source to wait for an event.  This function
applies @cfunc{ccevents_source_set} to the arguments @var{there} and @var{fdsrc}.  If an error
occurs: raise an exception by performing a non--local exit to @var{there}.

After the event represented by the arguments has been served or has expired: this function can be
called again for the same @var{fdsrc} to set up waiting for another event.

@var{fdsrc} is a pointer to an already initialised file descriptor events source.

@var{event_inquirer} is a pointer to the function used to query the file descriptor for events.
This function decides which events are expected: readability, writability, exceptional condition.

@var{event_handler} is a pointer to the function used to handle a file descriptor event.
@end deftypefun


To set up waiting for a readable event, in @math{5} seconds, on a pipe's file descriptor we can do
(using nested functions as allowed by a @gcc{} extension):

@smallexample
ccevents_group_t        grp[1];
ccevents_fd_source_t    fdsrc[1];
ccevents_timeout_t      expiration_time;
int                     X[2];
cce_location_t          L[1];

void event_handler (cce_location_t * there,
                    ccevents_group_t   * grp,
                    ccevents_source_t  * src)
@{
  // We should do something here.
  return;
@}
void expiration_handler (cce_location_t * there,
                         ccevents_group_t   * grp,
                         ccevents_source_t  * src)
@{
  // We should do something here.
  return;
@}

/* X[0] is the readable end.  X[1] is the writable end. */
pipe(X);

if (cce_location(L)) @{
  cce_run_error_handlers(L);
  cce_condition_free(cce_location_condition(L));
@} else @{
  ccevents_fd_event_source_init(fdsrc, X[0]);
  ccevents_fd_event_source_set(L, fdsrc,
    ccevents_query_fd_readability, event_handler);

  ccevents_timeout_init(L, &expiration_time, 5, 0, 0);
  ccevents_source_set_timeout(fdsrc,
    expiration_time, expiration_handler);

  ccevents_group_init(grp);
  ccevents_group_enqueue_source(grp, fdsrc);
  ccevents_group_enter(grp, 10);

  cce_run_cleanup_handlers(L);
@}
@end smallexample

@c page
@node fd query
@section Predefined query functions


@deftypefun bool ccevents_query_fd_readability (cce_location_t * @var{there}, ccevents_group_t * @var{grp}, ccevents_source_t * @var{fdsrc})
Query a file descriptor for readability.  This function matches the type
@objtype{ccevents_source_event_inquirer_fun_t}.  Return @true{} if the file descriptor is readable,
otherwise return @false{}.  If an error occurs: the value of @code{errno} might be mutated; an
exception is raised by performing a non--local exit to @var{there}.

If the file descriptor is not readable: the events source referenced by @var{fdsrc} is re--enqueued
in the group referenced by @var{grp}.

Beware that some file descriptors are always readable.
@end deftypefun


@deftypefun bool ccevents_query_fd_writability (cce_location_t * @var{there}, ccevents_group_t * @var{grp}, ccevents_source_t * @var{fdsrc})
Query a file descriptor for writability.  This function matches the type
@objtype{ccevents_source_event_inquirer_fun_t}.  Return @true{} if the file descriptor is writable,
otherwise return @false{}.  If an error occurs: the value of @code{errno} might be mutated; an
exception is raised by performing a non--local exit to @var{there}.

If the file descriptor is not writable: the events source referenced by @var{fdsrc} is re--enqueued
in the group referenced by @var{grp}.

Beware that some file descriptors are always writable.
@end deftypefun


@deftypefun bool ccevents_query_fd_exception (cce_location_t * @var{there}, ccevents_group_t * @var{grp}, ccevents_source_t * @var{fdsrc})
Query a file descriptor for an exception; this is useful when the file descriptor is a network
socket.  This function matches the type @objtype{ccevents_source_event_inquirer_fun_t}.  Return
@true{} if the file descriptor has received an exception signal, otherwise return @false{}.  If an
error occurs: the value of @code{errno} might be mutated; an exception is raised by performing a
non--local exit to @var{there}.

If the file descriptor has not received an exception: the events source referenced by @var{fdsrc} is
re--enqueued in the group referenced by @var{grp}.
@end deftypefun

@c page
@node signals
@chapter Interprocess signals


The block/unblock (@bub{}) @api{} is a simplified interface to detect the arrival of interprocess
signals; if it does not suit the application's model, we should just ignore it.

@menu
* signals bub::                 Setting up the block/unblock @api{}.
* signals sources::             Signals events sources.
@end menu

@c page
@node signals bub
@section Setting up the block/unblock @api{}


The following functions operate on global variables that are private to @value{PACKAGE}.  This makes
the @api{} multithread unsafe.


@deftypefun void ccevents_signal_bub_init (void)
Initialise the @bub{} @api{}, enabling signal handling.  Block all the signals and register a
handler for each.

For all the signals, the function @cfunc{sigaction} is called with a reference to @objtype{struct
sigaction} in which the field @code{.sa_flags} has the following flags set: @code{SA_RESTART},
@code{SA_NOCLDSTOP}.
@end deftypefun


@deftypefun void ccevents_signal_bub_final (void)
Finalise the @bub{} @api{}, disabling signal handling.  Set all the handlers to @code{SIG_IGN}, then
unblock the signals.
@end deftypefun


@deftypefun void ccevents_signal_bub_acquire (void)
Unblock then block all the signals.  This causes blocked signals to be delivered.
@end deftypefun


@deftypefun bool ccevents_signal_bub_delivered (int @var{signum})
Return @true{} if the signal @var{signum} was delivered to this process since the last call to
@cfunc{ccevents_signal_bub_init}, @cfunc{ccevents_signal_bub_final} or
@cfunc{ccevents_signal_bub_delivered} with this value of @var{signum}.  Calling this function clears
the internal flag for signal @var{signum}.  If the return value is @false{}: the signal was not
delivered.

@strong{NOTE} We need to remember that it is not possible to reliably determine the number of
signals of a kind sent to a process, because in some cases multiple signals are merged together.
@end deftypefun


As usage example, the following program will print @samp{true} and exit successfully:

@example
#include <ccevents.h>
#include <assert.h>
#include <stdlib.h>
#include <signal.h>

int
main (int argc, const char *const argv[])
@{
  ccevents_signal_bub_init();
  @{
    bool        flag;
    raise(SIGUSR1);
    ccevents_signal_bub_acquire();
    flag = ccevents_signal_bub_delivered(SIGUSR1);
    fprintf(stderr, "delivered? %s\n", ((flag)? "true" : "false"));
  @}
  ccevents_signal_bub_final();
  exit(EXIT_SUCCESS);
@}
@end example

@c page
@node signals sources
@section Signals events sources


To use the @api{} described here we have to initialise the signals @bub{} @api{} by calling
@cfunc{ccevents_signal_bub_init}.


@deftp {Struct Typedef} ccevents_signal_bub_source_t
Type of data structures using signals as events source through the @bub{} @api{}.  Every instance of
this type uses a single signal as source.
@end deftp


@deftypefun void ccevents_signal_bub_source_init (ccevents_task_source_t * @var{src}, int @var{signum})
Initialise an already allocated source structure to react to the delivery of signals of type
@var{signum}.  Apply @cfunc{ccevents_source_init} to @var{src}.  Do not start the event waiting:
this is done by @cfunc{ccevents_signal_bub_source_set}.

The event inquirer function associated to @var{src} calls @cfunc{ccevents_signal_bub_delivered} and,
if no signal was delivered, re--enqueues the source in the group; otherwise it leaves @var{src}
dequeued.
@end deftypefun


@deftypefun void ccevents_signal_bub_source_set (cce_location_t * @var{there}, ccevents_signal_source_t * @var{src}, ccevents_source_event_handler_fun_t * @var{event_handler})
Start the waiting for the selected signal.  Apply @cfunc{ccevents_source_set} to @var{src}.  If an
exceptional condition is raised: perform a non--local exit by jumping to @var{there}.
@end deftypefun


As example, here is how to setup an events source to wait for the delivery of @samp{SIGUSR1}:

@example
#include <ccevents.h>
#include <stdlib.h>
#include <signal.h>

static bool
acquire_signals_inquirer (cce_location_t    * there,
                          ccevents_group_t  * grp,
                          ccevents_source_t * src)
@{
  ccevents_signal_bub_acquire();
  ccevents_group_enqueue_source(grp, src);
  return false;
@}

static volatile sig_atomic_t signal_flag = 0;

static void
signal_handler (cce_location_t    * there,
                ccevents_group_t  * grp,
                ccevents_source_t * src)
@{
  signal_flag = 1;
@}

int
main (int argc, const char *const argv[])
@{
  ccevents_group_t grp[1];

  /* This events source runs its inquirer function again
     and again to acquire signals with the BUB API. */
  ccevents_task_source_t acquire_signals_src[1];

  /* This events source reacts to the delivery of SIGUSR1. */
  ccevents_signal_bub_source_t sigsrc[1];

  cce_location_t L[1];

  ccevents_signal_bub_init();
  @{
    ccevents_group_init(grp);
    ccevents_task_source_init(acquire_signals_src);
    ccevents_signal_bub_source_init(sigsrc, SIGUSR1);

    if (cce_location(L)) @{
      cce_run_error_handlers(L);
      cce_condition_free(cce_location_condition(L));
    @} else @{
      ccevents_task_source_set(L, acquire_signals_src,
         acquire_signals_inquirer,
         ccevents_source_dummy_event_handler);
      ccevents_signal_bub_source_set(L, sigsrc, signal_handler);
      ccevents_group_enqueue_source(grp, sigsrc);
      ccevents_group_enqueue_source(grp, acquire_signals_src);
      ccevents_group_enter(grp, 1000);
      cce_run_cleanup_handlers(L);
    @}
  @}
  ccevents_signal_bub_final();
  exit(EXIT_SUCCESS);
@}
@end example

@c page
@c ------------------------------------------------------------
@c Appendices.
@c ------------------------------------------------------------

@include lgpl-3.0.texi
@include fdl-1.3.texi

@c page
@node references
@appendix Bibliography and references


The documentation of @value{PACKAGE} is available online:

@center @value{DOCUMENTATION_URL}

@noindent
the latest release of this package can be downloaded from:

@center @value{DOWNLOAD_URL}

@noindent
development takes place at:

@center @value{GITHUB_URL}

@noindent
and as backup at:

@center @value{BITBUCKET_URL}

We can find the package  CCExceptions at:

@center @url{http://github.com/marcomaggi/ccexceptions/}

@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file

