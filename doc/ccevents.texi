\input texinfo.tex
@c %**start of header
@setfilename ccevents.info
@settitle CCEvents
@c %**end of header

@include version.texi
@include macros.texi

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      CCEvents

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    CCEvents

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           ccevents

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{marco.maggi-ipsu@@poste.it}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2017

@c ------------------------------------------------------------

@set GITHUB_URL                 @url{http://github.com/marcomaggi/@value{PACKAGE_NICKNAME}}
@set BITBUCKET_URL              @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}}
@set DOWNLOAD_URL               @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}/downloads}
@set DOCUMENTATION_URL          @url{http://marcomaggi.github.io/docs/@value{PACKAGE_NICKNAME}.html}

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
This document describes version @value{VERSION} of @value{PACKAGE}, a C language library
implementing an event loop.  It is written in C11 with @gcc{} extensions and it is meant to support
@gnu{}+Linux platforms.

The package is distributed under the terms of the @gnu{} Lesser General Public License (@lgpl{}).

The latest release can be downloaded from:

@center @value{DOWNLOAD_URL}

@noindent
development takes place at:

@center @value{GITHUB_URL}

@noindent
and as backup at:

@center @value{BITBUCKET_URL}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the @gnu{} Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with
Invariant Sections being ``@gnu{} Free Documentation License'' and
``@gnu{} General Public License'', no Front--Cover Texts, and no
Back--Cover Texts.  A copy of the license is included in the section
entitled ``@gnu{} Free Documentation License''.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @value{VERSION}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* ccevents: (ccevents).         CCEvents an event loop library.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* init::                        Library initialisation.
* version::                     Version functions.
* conditions::                  Exceptional condition objects.
* timevals::                    Handling time spans.
* timeouts::                    Handling event expiration times.
* sources::                     event sources basics.
* groups::                      Groups of event sources.
* loops::                       The main event loop.
* helpers::                     Helper functions and macros.

Appendices

* Package License::             GNU Lesser General Public License.
* Documentation License::       GNU Free Documentation License.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


This document describes version @value{VERSION} of @value{PACKAGE}, a C language library
implementing an event loop.  It is written in C11 with @gcc{} extensions.  The library is meant to
work on @gnu{}+Linux platforms.

There are plenty of mature event loop libraries already, for example @url{http://libuv.org/, Libuv}
and @url{http://software.schmorp.de/pkg/libev.html, Libev}.  While @value{PACKAGE} will, maybe,
never reach their level of features and reliability: it is an interesting exercise in programming.

This package depends on the package CCExceptions, at least version @samp{0.5}, to handle exceptional
conditions; @ref{references} for details on downloading it.

@value{PACKAGE} installs the single header file @file{ccevents.h}.  All the function names in the
@api{} are prefixed with @code{ccevents_}; all the constant names are prefixed with
@code{CCEVENTS_}; all the type names are prefixed with @code{ccevents_} and suffixed with @code{_t}.
The @api{}'s implementation defines a lot of inline functions.

The event loop implementation was initially inspired by the architecture of the event loop of
@url{http://www.tcl.tk/, Tcl}; however no code comes from Tcl itself.

Notice that, before using the library, we need to call the global initialisation function
@cfunc{ccevents_init}.

@strong{IMPORTANT} To use the library we must enable the @posix{} features when including the
standard header files; so either we include @file{ccevents.h} as first header, or we include the
following definitions before including @strong{all} the header files:

@example
#define _POSIX_C_SOURCE         200809L
@end example

@menu
* overview linking::            Linking code with the library.
@end menu

@c page
@node overview linking
@section Linking code with the library


This package installs a data file for @command{pkg-config}, so when searching for the installed
library with the @gnu{} Autotools, we can add the following macro use to @file{configure.ac}:

@example
PKG_CHECK_MODULES([CCEVENTS],[ccevents >= 0.1])
@end example

@noindent
which will set the variables @code{CCEVENTS_LIBS} and @code{CCEVENTS_CFLAGS}.  The macro
@code{PKG_CHECK_MODULES} is available in recent versions of @gnu{} Autoconf.

Alternatively we can use the raw @gnu{} Autoconf macros:

@example
AC_CHECK_LIB([ccevents],[ccevents_version_string],,
  [AC_MSG_FAILURE([test for CCEvents library failed])])
AC_CHECK_HEADERS([ccevents.h],,
  [AC_MSG_FAILURE([test for CCEvents header failed])])
@end example

We need to remember that client code using @value{PACKAGE}'s library must be written using the C11
language and the @gcc{} extensions enabled by @option{-fplan9-extensions}.

@c page
@node init
@chapter Library initialisation


@deftypefun void ccevents_init (void)
Initialises the internal structures of the library.  It is fine to call this function multiple
times.

@quotation
@strong{NOTE} This function is defined with the @gcc{} attribute @code{constructor}, so it will be
called automatically by the library initialisation code.
@end quotation
@end deftypefun

@c page
@node version
@chapter Version functions


The installed libraries follow version numbering as established by the
@gnu{} Autotools.  For an explanation of interface numbers as managed by
@gnu{} Libtool @xref{Libtool versioning, interface, Libtool's versioning
system, libtool, Shared library support for @gnu{}}.


@deftypefun {const char *} ccevents_version_string (void)
Return a pointer to a statically allocated @asciiz{} string representing
the interface version number.
@end deftypefun


@deftypefun int ccevents_version_interface_current (void)
Return an integer representing the library interface current number.
@end deftypefun


@deftypefun int ccevents_version_interface_revision (void)
Return an integer representing the library interface current revision
number.
@end deftypefun


@deftypefun int ccevents_version_interface_age (void)
Return an integer representing the library interface current age.
@end deftypefun

@c page
@node conditions
@chapter Exceptional condition objects


@value{PACKAGE} uses the external library CCExceptions to signal exceptional conditions and errors
through non--local exits; @xref{Top, CCExceptions, CCExceptions, ccexceptions, CCExceptions}.

The functions will raise exceptional conditions with @cfunc{cce_raise} and expect the caller to
intercept them using the @code{cce_location_t} mechanics.  The basic code template is:

@example
#include <ccevents.h>

cce_location_t  L[1];

if (cce_location(L)) @{
  /* Handle errors here. */
  cce_run_error_handlers_final(L);
@} else @{
  /* Do something useful here. */
  cce_run_cleanup_handlers(L);
@}
@end example

@menu
* conditions base::             Base exceptional conditions.
* conditions timevals::         Timeval exceptional conditions.
* conditions timeouts::         Timeout exceptional conditions.
@end menu

@c page
@node conditions base
@section Base exceptional conditions


@cindex Base exceptional condition
@cindex Exceptional conditions, base


@deftp {Struct Typedef} ccevents_descriptor_base_t
Type of data structure representing the base exceptional--condition descriptor for all the
conditions defined by @value{PACKAGE}.  It has the following public fields:

@table @code
@item cce_descriptor_t descriptor
The condition descriptor's base values.
@end table

The parent of this type descriptor is the root type descriptor defined by the CCExceptions library;
@xref{conditions root, CCExceptions, CCExceptions, ccexceptions, CCExceptions}.
@end deftp


@deftypevr {Dynamic Constant} {const ccevents_descriptor_base_t * const} ccevents_descriptor_base
Pointer to a statically allocated exceptional condition descriptor.
@end deftypevr


@deftypefun bool ccevents_condition_is_base (cce_condition_t const * @var{C})
Return @true{} if @var{C} is of type @objtype{ccevents_descriptor_base_t}; otherwise return
@false{}.
@end deftypefun

@c page
@node conditions timevals
@section Timeval exceptional conditions


@menu
* conditions timevals timeval::         Timeval exceptional conditions.
* conditions timevals invalid::         Invalid timeval values.
* conditions timevals overflow::        Overflow in timeval representation.
@end menu

@c page
@node conditions timevals timeval
@subsection Timeval exceptional conditions


@cindex Timeval, exceptional condition
@cindex Exceptional conditions, timeval


@deftp {Struct Typedef} ccevents_descriptor_timeval_t
Type of data structure representing a generic exceptional condition descriptor for all the
timeval--related errors; it is the base for all the timeval--related condition object types.  It has
the following public fields:

@table @code
@item cce_descriptor_t descriptor
The condition descriptor's base values.
@end table

The parent of this type descriptor is the one referenced by @code{ccevents_descriptor_base}.
@end deftp


@deftp {Struct Typedef} ccevents_condition_timeval_t
Type of data structure representing an exceptional condition object for a generic timeval--related
error.  It has the following public fields:

@table @code
@item cce_condition_t base
The condition object's base values.
@end table
@end deftp


@deftypevr {Dynamic Constant} {const ccevents_descriptor_timeval_t * const} ccevents_descriptor_timeval
Pointer to a statically allocated exceptional condition descriptor.
@end deftypevr


@deftypefun {cce_condition_t const *} ccevents_condition_new_timeval (void)
Return a pointer to exceptional condition object.
@end deftypefun


@deftypefun bool ccevents_condition_is_timeval (cce_condition_t const * @var{C})
Return @true{} if @var{C} if of type @code{ccevents_descriptor_timeval}; otherwise return @false{}.
@end deftypefun


To catch this exceptional condition we can do:

@smallexample
cce_location_t        L[1];

if (cce_location(L)) @{
  if (ccevents_condition_is_timeval(cce_condition(L))) @{
    CCEVENTS_PC(ccevents_condition_timeval_t, C, cce_condition(L));
    do_something_with(C);
  @}
  cce_run_error_handlers_final(L);
@} else @{
  do_something(L);
  cce_run_cleanup_handlers(L);
@}
@end smallexample

@c page
@node conditions timevals invalid
@subsection Invalid timeval values


@cindex Invalid timeval, exceptional condition
@cindex Timeval, invalid exceptional condition
@cindex Exceptional conditions, invalid timeval


@deftp {Struct Typedef} ccevents_descriptor_timeval_invalid_t
Type of data structure representing the exceptional condition descriptor for ``invalid timeval
initialisation'' errors.  It has the following public fields:

@table @code
@item cce_descriptor_t descriptor
The condition descriptor's base values.
@end table

The parent of this type descriptor is the one referenced by @code{ccevents_descriptor_timeval}.
@end deftp


@deftp {Struct Typedef} ccevents_condition_timeval_invalid_t
Type of data structure representing exceptional condition objects for ``invalid timeval
initialisation'' errors.  It has the following public fields:

@table @code
@item cce_condition_t timeval
The condition object's base values.
@end table
@end deftp


@deftypevr {Dynamic Constant} {const ccevents_descriptor_timeval_invalid_t * const} ccevents_descriptor_timeval_invalid
Pointer to a statically allocated exceptional condition descriptor.
@end deftypevr


@deftypefun {cce_condition_t const *} ccevents_condition_new_timeval_invalid (void)
Return a pointer to exceptional condition object.
@end deftypefun


@deftypefun bool ccevents_condition_is_timeval_invalid (cce_condition_t const * @var{C})
Return @true{} if @var{C} is an exceptional condition object with type descriptor
@code{ccevents_descriptor_timeval_invalid}; otherwise return @false{}.
@end deftypefun


To catch this exceptional condition we can do:

@smallexample
cce_location_t        L[1];

if (cce_location(L)) @{
  if (ccevents_condition_is_timeval_invalid(cce_condition(L))) @{
    CCEVENTS_PC(ccevents_condition_timeval_invalid_t, C, cce_condition(L));
    do_something_with(C);
  @}
  cce_run_error_handlers_final(L);
@} else @{
  do_something(L);
  cce_run_cleanup_handlers(L);
@}
@end smallexample

@c page
@node conditions timevals overflow
@subsection Overflow in timeval representation


@cindex Overflow in timeval, exceptional condition
@cindex Timeval, overflow exceptional condition
@cindex Exceptional conditions, overflow in timeval


@deftp {Struct Typedef} ccevents_descriptor_timeval_overflow_t
Type of data structure representing the exceptional condition descriptor for ``timeval
initialisation overflow'' errors.  It has the following public fields:

@table @code
@item cce_descriptor_t descriptor
The condition descriptor's base values.
@end table

The parent of this type descriptor is the one referenced by @code{ccevents_descriptor_timeval}.
@end deftp


@deftp {Struct Typedef} ccevents_condition_timeval_overflow_t
Type of data structure representing exceptional condition objects for ``timeval initialisation
overflow'' errors.  It has the following public fields:

@table @code
@item cce_condition_t timeval
The condition object's base values.
@end table
@end deftp


@deftypevr {Dynamic Constant} {const ccevents_descriptor_timeval_overflow_t * const} ccevents_descriptor_timeval_overflow
Pointer to a statically allocated exceptional condition descriptor.
@end deftypevr


@deftypefun {cce_condition_t const *} ccevents_condition_new_timeval_overflow (void)
Return a pointer to exceptional condition object.
@end deftypefun


@deftypefun bool ccevents_condition_is_timeval_overflow (cce_condition_t const * @var{C})
Return @true{} if @var{C} is an exceptional condition object with type descriptor
@code{ccevents_descriptor_timeval_overflow}; otherwise return @false{}.
@end deftypefun


To catch this exceptional condition we can do:

@smallexample
cce_location_t        L[1];

if (cce_location(L)) @{
  if (ccevents_condition_is_timeval_overflow(cce_condition(L))) @{
    CCEVENTS_PC(ccevents_condition_timeval_overflow_t, C, cce_condition(L));
    do_something_with(C);
  @}
  cce_run_error_handlers_final(L);
@} else @{
  do_something(L);
  cce_run_cleanup_handlers(L);
@}
@end smallexample

@c page
@node conditions timeouts
@section Timeout exceptional conditions


@menu
* conditions timeouts timeout::         Timeout exceptional conditions.
* conditions timeouts invalid::         Invalid timeout values.
* conditions timeouts overflow::        Overflow in timeout representation.
@end menu

@c page
@node conditions timeouts timeout
@subsection Timeout exceptional conditions


@cindex Timeout, exceptional condition
@cindex Exceptional conditions, timeout


@deftp {Struct Typedef} ccevents_descriptor_timeout_t
Type of data structure representing a generic exceptional condition descriptor for all the
timeout--related errors; it is the base for all the timeout--related condition object types.  It has
the following public fields:

@table @code
@item cce_descriptor_t descriptor
The condition descriptor's base values.
@end table

The parent of this type descriptor is the one referenced by @code{ccevents_descriptor_base}.
@end deftp


@deftp {Struct Typedef} ccevents_condition_timeout_t
Type of data structure representing an exceptional condition object for a generic timeout--related
error.  It has the following public fields:

@table @code
@item cce_condition_t base
The condition object's base values.
@end table
@end deftp


@deftypevr {Dynamic Constant} {const ccevents_descriptor_timeout_t * const} ccevents_descriptor_timeout
Pointer to a statically allocated exceptional condition descriptor.
@end deftypevr


@deftypefun {cce_condition_t const *} ccevents_condition_new_timeout (void)
Return a pointer to exceptional condition object.
@end deftypefun


@deftypefun bool ccevents_condition_is_timeout (cce_condition_t const * @var{C})
Return @true{} if @var{C} if of type @code{ccevents_descriptor_timeout}; otherwise return @false{}.
@end deftypefun


To catch this exceptional condition we can do:

@smallexample
cce_location_t        L[1];

if (cce_location(L)) @{
  if (ccevents_condition_is_timeout(cce_condition(L))) @{
    CCEVENTS_PC(ccevents_condition_timeout_t, C, cce_condition(L));
    do_something_with(C);
  @}
  cce_run_error_handlers_final(L);
@} else @{
  do_something(L);
  cce_run_cleanup_handlers(L);
@}
@end smallexample

@c page
@node conditions timeouts invalid
@subsection Invalid timeout values


@deftp {Struct Typedef} ccevents_descriptor_timeout_invalid_t
Type of data structure representing the exceptional condition descriptor for ``invalid timeout
initialisation'' errors.  It has the following public fields:

@table @code
@item cce_descriptor_t descriptor
The condition descriptor's base values.
@end table

The parent of this type descriptor is the one referenced by @code{ccevents_descriptor_timeout}.
@end deftp


@deftp {Struct Typedef} ccevents_condition_timeout_invalid_t
Type of data structure representing exceptional condition objects for ``invalid timeout
initialisation'' errors.  It has the following public fields:

@table @code
@item ccevents_condition_timeout_t timeout
The condition object's base values.
@end table
@end deftp


@deftypevr {Dynamic Constant} {const ccevents_descriptor_timeout_invalid_t * const} ccevents_descriptor_timeout_invalid
Pointer to a statically allocated exceptional condition descriptor.
@end deftypevr


@deftypefun {cce_condition_t const *} ccevents_condition_new_timeout_invalid (void)
Return a pointer to exceptional condition object.
@end deftypefun


@deftypefun bool ccevents_condition_is_timeout_invalid (cce_condition_t const * @var{C})
Return @true{} if @var{C} is an exceptional condition object with type descriptor
@code{ccevents_descriptor_timeout_invalid}; otherwise return @false{}.
@end deftypefun


To catch this exceptional condition we can do:

@smallexample
cce_location_t        L[1];

if (cce_location(L)) @{
  if (ccevents_conition_is_timeval_invalid(cce_condition(L))) @{
    CCEVENTS_PC(ccevents_condition_timeout_invalid_t, C, cce_condition(L));
    do_something_with(C);
  @}
  cce_run_error_handlers(L);
  cce_condition_free(cce_condition(L));
@} else @{
  do_something(L);
  cce_run_cleanup_handlers(L);
@}
@end smallexample

@c page
@node conditions timeouts overflow
@subsection Overflow in timeout representation


@deftp {Struct Typedef} ccevents_descriptor_timeout_overflow_t
Type of data structure representing the exceptional condition descriptor for ``timeout
initialisation overflow'' errors.  It has the following public fields:

@table @code
@item cce_descriptor_t descriptor
The condition descriptor's base values.
@end table

The parent of this type descriptor is the one referenced by @code{ccevents_descriptor_timeout}.
@end deftp


@deftp {Struct Typedef} ccevents_condition_timeout_overflow_t
Type of data structure representing exceptional condition objects for ``timeout initialisation
overflow'' errors.  It has the following public fields:

@table @code
@item ccevents_condition_timeout_t timeout
The condition object's base values.
@end table
@end deftp


@deftypevr {Dynamic Constant} {const ccevents_descriptor_timeout_overflow_t * const} ccevents_descriptor_timeout_overflow
Pointer to a statically allocated exceptional condition descriptor.
@end deftypevr


@deftypefun {cce_condition_t const *} ccevents_condition_new_timeout_overflow (void)
Return a pointer to exceptional condition object.
@end deftypefun


@deftypefun bool ccevents_condition_is_timeout_overflow (cce_condition_t const * @var{C})
Return @true{} if @var{C} is an exceptional condition object with type descriptor
@code{ccevents_descriptor_timeout_overflow}; otherwise return @false{}.
@end deftypefun


To catch this exceptional condition we can do:

@smallexample
cce_location_t        L[1];

if (cce_location(L)) @{
  if (ccevents_condition_is_timeout_overflow(cce_condition(L))) @{
    CCEVENTS_PC(ccevents_condition_timeout_overflow_t, C, cce_condition(L));
    do_something_with(C);
  @}
  cce_run_error_handlers(L);
  cce_condition_free(cce_condition(L));
@} else @{
  do_something(L);
  cce_run_cleanup_handlers(L);
@}
@end smallexample

@c page
@node timevals
@chapter Handling time spans


It is typical for a C language system function, under a Unix--like system, to require a @code{struct
timeval} value to represent a time span; @value{PACKAGE} implements an @api{} to handle such
objects.

The @api{} is peculiar because often it requires the whole data structure to passed by value, rather
than using a pointer to structure as is usually the case.


@deftp {Struct Typedef} ccevents_timeval_t
An alias for @objtype{struct timeval} used to represent normalised values.  A normalised value is
such that the fields @code{tv_sec} and @code{tv_usec} obey the following constraints:

@example
0 <= tv_sec  <= LONG_MAX
0 <= tv_usec <= 999999
@end example

This type has the following public fields:

@table @code
@item struct timeval;
An anonymous field.
@end table

To copy a timeval data structure we can use the C language @code{=} operator.
@end deftp


@deftypefun ccevents_timeval_t ccevents_timeval_init (cce_location_t * @var{there}, long @var{seconds}, long @var{microseconds})
Build and return a timeval structure initialised and normalised with the given arguments.  If an
error occurs while normalising: an exception is raised by performing a non--local exit to
@var{there}.

The argument @var{seconds} is meant to be in the range @samp{[0, LONG_MAX]}.  The argument
@var{microseconds} is meant to be in the range @samp{[LONG_MIN, LONG_MAX]}.
@end deftypefun


@deftypevr {Dynamic Constant} {const ccevents_timeval_t *} CCEVENTS_TIMEVAL_NEVER
Pointer to a constant, statically--allocated instance of @objtype{ccevents_timeval_t} representing a
timeval that, interpreted as expiration time, never expires.
@end deftypevr


@deftypefun ccevents_timeval_t ccevents_timeval_normalise (cce_location_t * @var{there}, struct timeval @var{T})
Build and return a timeval structure initialised and normalised with the given arguments.  If an
error occurs while normalising: an exception is raised by performing a non--local exit to
@var{there}.

The field @code{tv_sec} of @var{T} is meant to be in the range @samp{[0, LONG_MAX]}.  The field
@code{tv_usec} of @var{T} is meant to be in the range @samp{[LONG_MIN, LONG_MAX]}.
@end deftypefun


@deftypefun ccevents_timeval_t ccevents_timeval_add (cce_location_t * @var{there}, const ccevents_timeval_t @var{A}, const ccevents_timeval_t @var{B})
Add the two timeval values @var{A} and @var{B} and return a normalised timeval value.  If an error
occurs while adding or normalising: an exception is raised by performing a non--local exit to
@var{there}.
@end deftypefun


@deftypefun ccevents_timeval_t ccevents_timeval_sub (cce_location_t * @var{there}, const ccevents_timeval_t @var{A}, const ccevents_timeval_t @var{B})
Subtract @var{B} from @var{A} and return a normalised timeval value representing the difference.  If
an error occurs while subtracting or normalising: an exception is raised by performing a non--local
exit to @var{there}.
@end deftypefun


@deftypefun int ccevents_timeval_compare (const ccevents_timeval_t @var{A}, const ccevents_timeval_t @var{B})
Compare the timeval values @var{A} and @var{B}.  Return:

@table @code
@item 0
If @var{A} is equal to @var{B}.

@item +1
If @var{A} is greater than @var{B}.

@item -1
If @var{A} is less than @var{B}.
@end table
@end deftypefun


@deftypefun bool ccevents_timeval_is_expired_timeout (const ccevents_timeval_t @var{expiration_time})
Consider the argument as a calendar time representing the expiration time of a timeout.  Acquire the
current time and compare it with @var{expiration_time}: return @true{} if the timeout has expired;
otherwise return @false{}.
@end deftypefun


@deftypefun bool ccevents_timeval_is_infinite_timeout (const ccevents_timeout_t @var{T})
Consider the argument as a calendar time representing the expiration time of a timeout.  Return
@true{} if @var{T} represents a timeout that (conventionally) will never expire; otherwise return
@false{}.  The timeout is considered to never expire if the field @code{tv_sec} is set to
@code{LONG_MAX}.
@end deftypefun

@c page
@node timeouts
@chapter Handling event expiration times


This module implements ``polling timeouts'': we set a timeout using this @api{} and when it expires
nothing happens, we have to call a function to verify if it has expired or not.  A timeout is meant
to be used to signal that an event has not happened in a fixed amount of time.

Here is an example of code that initialises a timeout @var{to} that will expire @math{1} second,
@math{2} milliseconds and @math{3} microseconds after the time of the call to
@cfunc{ccevents_timeout_start}; the expiration time is represented by the
@objtype{ccevents_timeval_t} variable @var{tv}:

@example
#include <ccevents.h>

cce_location_t          L[1];

if (cce_location(L)) @{
  cce_run_error_handlers(L);
  cce_condition_free(cce_condition(L));
@} else @{
  ccevents_timeout_t    to;
  ccevents_timeval_t    tv;

  to = ccevents_timeout_init(L, 1, 2, 3);
  tv = ccevents_timeout_start(L, to);
  cce_run_cleanup_handlers(L);
@}
@end example

The @api{} is peculiar because instances of @objtype{ccevents_timeout_t} are always passed by value.


@deftp {Struct Typedef} ccevents_timeout_t
Type of data structures representing a time span from a point in time towards the future.

Holds values for seconds, milliseconds and microseconds as @code{long int}.  The number of seconds
can only be zero or positive; the numbers of milliseconds and microseconds are normalised by
@cfunc{ccevents_timeout_init} to the range @code{[0, 999]}; the normalisation process can lead to an
overflow, which is signalled by raising an exception.

The maximum representable time span is: @code{LONG_MAX-1} seconds, @code{999} milliseconds,
@code{999} microseconds.  When the number of seconds is set to @code{LONG_MAX}: the time span is
interpreted as ``infinite'', the timeout will never expire.

To copy a timeout data structure we can use the C language @code{=} operator.
@end deftp


@deftypefun ccevents_timeout_t ccevents_timeout_init (cce_location_t * @var{there}, long @var{seconds}, long @var{milliseconds}, long @var{microseconds})
Build and return a timeout structure.  The arguments @var{seconds}, @var{milliseconds} and
@var{microseconds} represent a time span towards the future:

@table @var
@item seconds
It is a count of seconds; it must be in the range @code{[0, LONG_MAX]}.  It is normalised to the
range @code{[0, LONG_MAX]}.

@item milliseconds
It is a count of milliseconds; it must be in the range @code{[LONG_MIN, LONG_MAX]}.  It is
normalised to the range @code{[0, 999]}.

@item microseconds
It is a count of microseconds; it must be in the range @code{[LONG_MIN, LONG_MAX]}.  It is
normalised to the range @code{[0, 999]}.
@end table

If an error occurs while normalising the given time span specification: raise an exception by
performing a non--local exit to @var{there}.
@end deftypefun


@deftypevr {Dynamic Constant} {const ccevents_timeout_t *} CCEVENTS_TIMEOUT_NEVER
Pointer to a constant, statically--allocated instance of @objtype{ccevents_timeout_t} representing a
timeout that never expires.
@end deftypevr


@deftypevr {Dynamic Constant} {const ccevents_timeout_t *} CCEVENTS_TIMEOUT_NOW
Pointer to a constant, statically--allocated instance of @objtype{ccevents_timeout_t} representing a
timeout that expires immediately.
@end deftypevr


@deftypefun long ccevents_timeout_seconds (const ccevents_timeout_t @var{to})
Return the current number of seconds.  The value is in the range @code{[0, LONG_MAX]}.
@end deftypefun


@deftypefun long ccevents_timeout_milliseconds (const ccevents_timeout_t @var{to})
Return the current number of milliseconds.  The value is in the range @code{[0, 999]}.
@end deftypefun


@deftypefun long ccevents_timeout_microseconds (const ccevents_timeout_t @var{to})
Return the current number of microseconds.  The value is in the range @code{[0, 999]}.
@end deftypefun


@deftypefun bool ccevents_timeout_is_infinite (const ccevents_timeout_t @var{to})
Return @true{} if @var{to} represents an ``infinite'' time span; otherwise return @false{}.

If a timeout never expires, applying @cfunc{ccevents_timeval_is_expired_timeout} to the return value
of @cfunc{ccevents_timeout_start} will never return true:

@example
#include <ccevents.h>

cce_location_t          L[1];

if (cce_location(L)) @{
  cce_run_error_handlers(L);
  cce_condition_free(cce_condition(L));
@} else @{
  ccevents_timeout_t to;
  ccevents_timeval_t tv;

  to = ccevents_timeout_init(L, LONG_MAX, 0, 0);
  tv = ccevents_timeout_start(L, to);

  /* This returns true. */
  ccevents_timeout_is_infinite(to);

  /* This will always return false. */
  ccevents_timeval_expired(tv);

  cce_run_cleanup_handlers(L);
@}
@end example
@end deftypefun


@deftypefun int ccevents_timeout_compare (const ccevents_timeout_t @var{A}, const ccevents_timeout_t @var{B})
Compare the time spans of two timeouts; return: @code{-1} if @code{@var{A} < @var{B}}, @code{0} if
@code{@var{A} == @var{B}}, @code{+1} if @code{@var{A} > @var{B}}.
@end deftypefun


@deftypefun ccevents_timeval_t ccevents_timeout_start (cce_location_t * @var{there}, const ccevents_timeout_t @var{to})
Start the timer associated to the timeout @var{to}: acquire the current absolute time and compute
the time instant that will expire the timeout.  Return a timeval structure representing the
expiration time.  If an error occurs: raise an exception by performing a non--local exit to
@var{there}.

As a special case: if the time span is infinite, the expiration time is set to: @code{LONG_MAX}
seconds; this should guarantee that the timeout will never expire.
@end deftypefun

@c page
@node sources
@chapter Event sources basics


Event sources are the basic building blocks of event loops managed by @value{PACKAGE}.  Events
always come from a ``source'', be it an operating system timer, a single file descriptor, a group of
network sockets representing connections to a server, a file system change monitored with the
@samp{inotify} @api{}, et cetera.

@value{PACKAGE} defines some predefined event source types, and we can define new ones.  All of them
are subtypes of @objtype{ccevents_source_t}.

@menu
* sources base::                Base event sources @api{}.
* sources tasks::               Performing tasks in steps.
* sources timers::              Timer event sources.
* sources fd::                  Event source for file descriptors.
* sources signals::             Interprocess signals.
@end menu

@c page
@node sources base
@section Base event sources @api{}


@menu
* sources base typedefs::       Type definitions.
* sources base api::            Application programming interface.
* sources base example::        Example of event source definition.
@end menu

@c page
@node sources base typedefs
@subsection Type definitions


@deftp {Struct Typedef} ccevents_source_t
Base structure type for all the event source types.  Instances of this structure must be initialised
with a call to @cfunc{ccevents_source_init} and finalised with a call to
@cfunc{ccevents_source_final}.

Every event source is meant to be associated to a group, @ref{groups, Groups of event sources}.
Sources are enqueued in a group by calling @cfunc{ccevents_group_enqueue_source}; sources are
dequeued from their group by calling @cfunc{ccevents_source_dequeue_itself}.

Servicing events can be enabled or disabled; the default after the call to
@cfunc{ccevents_source_init} is to enable servicing.  To enable servicing we call
@cfunc{ccevents_source_enable_servicing}; to disable it we call
@cfunc{ccevents_source_disable_servicing}.

Every event source contains an expiration timeout, selected with
@cfunc{ccevents_source_set_timeout}; it is meant to be used in one of two ways:

@itemize
@item
The next event from the source must be served before the timeout expires, otherwise special handling
is triggered.

@item
The whole use of a source must be completed before the timeout expires, otherwise special handling
is triggered.
@end itemize

@noindent
By default, the timeout is set to ``never expire'' and an internal expiration handler that does
nothing is registered in the source structure.
@end deftp

@c ------------------------------------------------------------------------

@subsubheading Event methods table


@deftypefn {Function Type} bool ccevents_event_inquirer_t (cce_location_t * @var{there}, ccevents_source_t * @var{src})
Function prototype of event inquiry functions.  A function of this type is meant to query the event
source referenced by @var{src} to determine if an event is pending or not:

@itemize
@item
If an event is pending: it must return @true{}.

@item
If no event is pending: it must return @false{}.

@item
If inquiring for events raises an exceptional condition: a non--local exit must be performed by
jumping to @var{there}.
@end itemize

Implementations of this function prototype, and exceptional condition handlers registered in the
@objtype{cce_location_t} mechanism, are allowed to remove the source from its group using
@cfunc{ccevents_source_dequeue_itself}.
@end deftypefn


@deftypefn {Function Type} void ccevents_event_handler_t (cce_location_t * @var{there}, ccevents_source_t * @var{src})
Function prototype of event handler functions.  A function of this type is meant to serve a pending
event on the event source referenced by @var{src}.  If serving the event raises an exceptional
condition: a non--local exit must be performed by jumping to @var{there}.

Functions of this type are meant to be called only after the event inquirer function, applied to the
same operands, returned @true{}.

Implementations of this function prototype, and exceptional condition handlers registered in the
@objtype{cce_location_t} mechanism, are allowed to remove the source from its group using
@cfunc{ccevents_source_dequeue_itself}.

Typically, an event source has multiple event handlers that are selected in turn, implementing a
state machine; after an event handler has served an event (say: by reading data from a network
socket), it selects another handler to move on the computation (say: to write data to the same
network socket).

If we want the source timeout to be associated to the event: every time the event handler is
invoked, it must reset the timeout for the next run, using @cfunc{ccevents_source_set_timeout}.
@end deftypefn


@deftypefn {Function Type} void ccevents_timeout_handler_t (cce_location_t * @var{there}, ccevents_source_t * @var{src})
Function prototype of expiration handler functions.  A function of this type is meant to react to a
timeout expiration associated to the event source referenced by @var{src}.  If handling the timeout
raises an exceptional condition: a non--local exit must be performed by jumping to @var{there}.

Implementations of this function prototype, and exceptional condition handlers registered in the
@objtype{cce_location_t} mechanism, are allowed to remove the source from its group using
@cfunc{ccevents_source_dequeue_itself}.
@end deftypefn


@deftp {Struct Typedef} ccevents_source_vtable_t
Structure type representing a table of methods acting on an event source.  Every subtype of
@objtype{ccevents_source_t} must define an instance of this table and use it in a call to
@cfunc{ccevents_source_init}.  It has the following public fields:

@table @code
@item ccevents_event_inquirer_t * event_inquirer
Pointer to the event inquirer function.  It is called to determine if the event source has a
pending event or not.

@item ccevents_event_handler_t * event_handler
Pointer to the event handler function.  It is called to serve a pending event.
@end table

See @cfunc{ccevents_source_do_one_event} for details on how these functions are used.
@end deftp

@c ------------------------------------------------------------------------

@subsubheading Object methods table


The event sources defined by @value{PACKAGE} do @strong{not require any finalisation}; it is
responsibility of the client code to release the memory allocated to @objtype{ccevents_source_t}, if
there is the need to do so.  Nevertheless it is possible to register a finalisation function using
the following types.


@deftypefn {Function Type} void ccevents_source_final_t (ccevents_source_t * @var{src})
Finalisation function for structures of type @objtype{ccevents_source_t}.
@end deftypefn


@deftp {Struct Typedef} ccevents_source_otable_t
Type of structures representing tables of function to handle instances of
@objtype{ccevents_source_t}.  We can associate a source structure to a table by calling
@cfunc{ccevents_source_set_otable}.  A table has the following fields:

@table @code
@item ccevents_source_final_t * final
Pointer to a finalisation function.  This function is called by @cfunc{ccevents_source_final}.
@end table
@end deftp


@deftypevr {Dynamic Constant} {const ccevents_source_otable_t * const} ccevents_source_otable_default
Pointer to a predefined table of object methods; it is the default table selected by
@cfunc{ccevents_source_init}.  It is set with the following functions:

@table @code
@item final
A finalisation function that does nothing.
@end table
@end deftypevr


As example, if we want to use the standard @cfunc{free} function to finalise a source structure we
can do as follows:

@example
#include <ccevents.h>
#include <stdlib.h>

static void
my_source_final (ccevents_source_t * src)
@{
  free(src);
@}

const ccevents_source_otable_t otable = @{
  .final = my_source_final
@}
@end example

@c page
@node sources base api
@subsection Application programming interface


@deftypefun void ccevents_source_init (ccevents_source_t * @var{src}, const ccevents_source_vtable_t * @var{vtable})
Initialise an already allocated event source structure referenced by @var{src}.  This function is
typically invoked by the initialisation function of the event source subtype.  Register @var{vtable}
as table of function pointers acting on this specific event source type.

Set the event expiration timeout to never: if this setting is not overridden with
@cfunc{ccevents_source_set_timeout}, waiting for events on this source will never expire.

The internal table of object methods is set to @code{ccevents_source_otable_default}.
@end deftypefun


@deftypefun void ccevents_source_final (ccevents_source_t * @var{src})
Finalise the source using the finalisation function in the registered instance of
@objtype{ccevents_source_otable_t}.  This function is called by @cfunc{ccevents_group_final} for any
source still enqueued in the group.
@end deftypefun


@deftypefun void ccevents_source_set_otable (ccevents_source_t * @var{src}, const ccevents_source_otable_t * @var{otable})
Select a table of object methods.
@end deftypefun


@deftypefun void ccevents_source_set_timeout (ccevents_source_t * @var{src}, ccevents_timeval_t @var{expiration_time}, ccevents_timeout_handler_t * @var{expiration_handler})
Setup a new expiration timeout.  The argument @var{expiration_time} is usually the return value of a
call to @cfunc{ccevents_timeout_start}, so the timeout has already started; so when this function is
called, the timeout has already started.
@end deftypefun


@deftypefun bool ccevents_source_do_one_event (cce_location_t * @var{there}, ccevents_source_t * @var{src})
If servicing events for this source is enabled: consume one event, if there is one, from the event
source referenced by @var{src}.  Return @true{} if one event was served or the timeout expired;
otherwise return @false{}.  If an exceptional condition is raised: a non--local exit is performed by
jumping to @var{there}.

If servicing events for this source is disabled: do nothing and return @false{}.

Event servicing is performed with the following steps:

@enumerate
@item
Check the expiration timeout: if the timeout has expired, call the expiration handler and return
@true{}.  If the expiration handler function raises an exceptional condition: a non--local exit is
performed by jumping to @var{there}.

@item
Query the event source for the availability of an event, using the event inquirer.  If no event is
pending: return @false{}.  If the event inquiry function raises an exceptional condition: a
non--local exit is performed by jumping to @var{there}.

@item
If an event is pending: call the event handler function and return @true{}.  If the event handler
function raises an exceptional condition: a non--local exit is performed by jumping to @var{there}.
@end enumerate
@end deftypefun


@deftypefun void ccevents_source_dequeue_itself (ccevents_source_t * @var{src})
Remove the source referenced by @var{src} from its group.  If @var{src} is not enqueued in a group:
nothing happens.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Inspection functions


@deftypefun bool ccevents_source_is_enqueued (const ccevents_source_t * @var{src})
Return @true{} if the source is enqueued in a group, otherwise return @false{}.
@end deftypefun


@deftypefun {ccevents_group_t *} ccevents_source_get_group (const ccevents_source_t * @var{src})
If the source is enqueued in a group: return a pointer to that group; otherwise return @false{}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Enabling and disabling servicing


When a source is disabled: a call to @cfunc{ccevents_source_do_one_event} will do nothing.  If the
source is enqueued in a group: @cfunc{ccevents_group_enter} will visit the source and just do
nothing.

This might be useful, for example, in this scenario: we want two processes A and B to communicate
through Unix pipes; process B is spawned by process A; a call to @cfunc{pipe} configures two file
descriptors, one for reading and one for writing.  We set up the following mechanism:

@enumerate
@item
In process A we allocate two pipes, then we spawn process B.  Process A will keep a reading end and
a writing end; it will close the other ends.  Process B will keep the other ends.

@item
In each process, we create an event source for each file descriptor; in each process, we enqueue
both the sources in a group.

@item
When it is the turn of process A to read: in process A, we enable the reading source and disable the
writing source; in process B, we enable the writing source and disable the reading source.

@item
When it is the turn of process A to write: in process A, we enable the writing source and disable
the reading source; in process B, we enable the reading source and disable the writing source.

@item
When communication is over: in each process we dequeue both the sources from the group.
@end enumerate


@deftypefun bool ccevents_source_servicing_is_enabled (const ccevents_source_t * @var{src})
Return @true{} if servicing events for this source is enabled; otherwise return @false{}.
@end deftypefun


@deftypefun void ccevents_source_enable_servicing (ccevents_source_t * @var{src})
@deftypefunx void ccevents_source_disable_servicing (ccevents_source_t * @var{src})
Enable or disable servicing events for this source.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Dummy event handlers and inquiry functions


@deftypevr {Function Pointer} ccevents_event_inquirer_t ccevents_dummy_event_inquirer_true
@deftypevrx {Function Pointer} ccevents_event_inquirer_t ccevents_dummy_event_inquirer_false
Dummy event inquirer functions: do nothing and return, respectively, @true{} and @false{}.
@end deftypevr


@deftypevr {Function Pointer} ccevents_event_handler_t ccevents_dummy_event_handler
A dummy event handler function: does nothing.
@end deftypevr


@deftypevr {Function Pointer} ccevents_timeout_handler_t ccevents_dummy_timeout_handler
A dummy timeout handler function: does nothing.
@end deftypevr

@c page
@node sources base example
@subsection Example of event source definition


To understand how event sources are subtyped and used, let's look at a possible implementation of
the task event source defined by @value{PACKAGE}:

@smallexample
typedef struct ccevents_task_source_t @{
  ccevents_source_t;
  ccevents_event_inquirer_t * event_inquirer;
  ccevents_event_handler_t  * event_handler;
@} ccevents_task_source_t;

static bool
method_event_inquirer (cce_location_t * there, ccevents_source_t * src)
@{
  CCEVENTS_PC(ccevents_task_source_t, tksrc, src);
  return tksrc->event_inquirer(there, tksrc);
@}

static void
method_event_handler (cce_location_t * there, ccevents_source_t * src)
@{
  CCEVENTS_PC(ccevents_task_source_t, tksrc, src);
  return tksrc->event_handler(there, tksrc);
@}

static const ccevents_source_vtable_t methods_table = @{
  .event_inquirer       = method_event_inquirer,
  .event_handler        = method_event_handler,
@};

void
ccevents_task_source_init (ccevents_task_source_t * tksrc)
@{
  ccevents_source_init(tksrc, &methods_table);
@}

void
ccevents_task_source_set (ccevents_task_source_t * tksrc,
    ccevents_event_inquirer_t * event_inquirer,
    ccevents_event_handler_t  * event_handler)
@{
  tksrc->event_inquirer = event_inquirer;
  tksrc->event_handler  = event_handler;
@}
@end smallexample

@noindent
this module is used as follows:

@smallexample
#include <ccevents.h>

bool
event_inquirer (cce_location_t * there, ccevents_source_t * src)
@{
  // The next step is always ready to be executed.
  return true;
@}
void
expiration_handler (cce_location_t * there, ccevents_source_t * src)
@{
  // Handle the expiration here.
@}

void
step1 (cce_location_t * there, ccevents_source_t * src)
@{
  CCEVENTS_PC(ccevents_task_source_t, tksrc, src);
  // Perform the first step here.
  ccevents_task_source_set(tksrc, event_inquirer, step2);
@}
void
step2 (cce_location_t * there, ccevents_source_t * src)
@{
  CCEVENTS_PC(ccevents_task_source_t, tksrc, src);
  // Perform the second step here.
  ccevents_task_source_set(tksrc, event_inquirer, step3);
@}
void
step3 (cce_location_t * there, ccevents_source_t * src)
@{
  // Perform the third step here.
@}

void
doit (void)
@{
  cce_location_t        L[1];

  if (cce_location(L)) @{
    cce_run_error_handlers(L);
    cce_condition_free(cce_condition(L));
  @} else @{
    ccevents_group_t            grp[1];
    ccevents_task_source_t      tksrc[1];

    ccevents_task_source_init(tksrc);
    ccevents_task_source_set(tksrc, event_inquirer, step1);
    ccevents_group_init(grp, 3);
    ccevents_group_enqueue_source(grp, tksrc);
    ccevents_group_enter(grp);
    cce_run_cleanup_handlers(L);
  @}
@}
@end smallexample

@c page
@node sources tasks
@section Performing tasks in steps


The task source is the most basic event source defined by @value{PACKAGE}.


@deftp {Struct Typedef} ccevents_task_source_t
Type of task event source.  It is ``derived'' from @objtype{ccevents_source_t}, meaning that the
first field of @objtype{ccevents_task_source_t} is an anonymous field of type
@objtype{ccevents_source_t}.
@end deftp


@deftypefun void ccevents_task_source_init (ccevents_task_source_t * @var{src})
Initialise an already allocated task source structure referenced by @var{src}.  Apply
@cfunc{ccevents_source_init} to @var{src}.
@end deftypefun


@deftypefun void ccevents_task_source_set (ccevents_task_source_t * @var{tksrc}, ccevents_event_inquirer_t * @var{event_inquirer}, ccevents_event_handler_t * @var{event_handler})
Register the handlers for the next step in performing the task.  The @var{event_handler} is meant
perform a task step and to call this function again to select the next step.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Cast functions


@deftypefun {ccevents_task_source_t *} ccevents_cast_to_task_source_from_source (ccevents_source_t * @var{src})
Cast function which explicitly documents that this pointer type conversion is sometimes necessary.
We can use it, for example, in an event handler function as follows:

@example
void
event_handler (cce_location_t * there, ccevents_source_t * src)
@{
  ccevents_task_source_t * tsksrc =
    ccevents_cast_to_task_source_from_source(src);
  ...
@}
@end example
@end deftypefun


@deftypefn {Generic Macro} {ccevents_task_source_t *} ccevents_cast_to_task_source (ccevents_source_t * @var{src})
Generic cast macro which explicitly documents that this pointer type conversion is sometimes
necessary.  We can use it, for example, in an event handler function as follows:

@example
void
event_handler (cce_location_t * there, ccevents_source_t * src)
@{
  ccevents_task_source_t * tsksrc =
    ccevents_cast_to_task_source(src);
  ...
@}
@end example
@end deftypefn

@c ------------------------------------------------------------------------

@subsubheading Usage example

The task source is meant to be used as follows:

@smallexample
#include <ccevents.h>

bool
event_inquirer (cce_location_t * there, ccevents_source_t * src)
@{
  // The next step is always ready to be executed.
  return true;
@}
void
expiration_handler (cce_location_t * there, ccevents_source_t * src)
@{
  // Handle the expiration here.
@}

void
step1 (cce_location_t * there, ccevents_source_t * src)
@{
  ccevents_task_source_t * tksrc = ccevents_cast_to_task_source(src);
  // Perform the first step here.
  ccevents_task_source_set(tksrc, event_inquirer, step2);
@}
void
step2 (cce_location_t * there, ccevents_source_t * src)
@{
  ccevents_task_source_t * tksrc = ccevents_cast_to_task_source(src);
  // Perform the second step here.
  ccevents_task_source_set(tksrc, event_inquirer, step3);
@}
void
step3 (cce_location_t * there, ccevents_source_t * src)
@{
  ccevents_task_source_t * tksrc = ccevents_cast_to_task_source(src);
  // Perform the third step here.
  ccevents_source_dequeue_itself(src);
@}

void
doit (void)
@{
  ccevents_group_t              grp[1];
  ccevents_task_source_t        tksrc[1];
  cce_location_t                L[1];

  if (cce_location(L)) @{
    cce_run_error_handlers(L);
    cce_condition_free(cce_condition(L));
  @} else @{
    ccevents_task_source_init(tksrc);
    ccevents_task_source_set(tksrc, event_inquirer, step1);
    ccevents_group_init(grp);
    ccevents_group_enqueue_source(grp, tksrc);
    ccevents_group_enter(grp, 3);
    cce_run_cleanup_handlers(L);
  @}
@}
@end smallexample

@c page
@node sources timers
@section Timer event sources


The timer event sources defined by this @api{} trigger an event whenever the event loop examines the
timer event source structure and finds that the timeout has expired; there is no special mechanism
to interrupt the process execution and signal a timer (for example: this @api{} does not use
@posix{}'s @cfunc{timer_create}).


@deftp {Struct Typedef} ccevents_timer_source_t
A simple source that exploits the timeout mechanism to implement a timer.  The timer's calendar time
and the expiration handler are selected with @cfunc{ccevents_source_set_timeout}.
@end deftp


@deftypefun void ccevents_timer_source_init (ccevents_timer_source_t * @var{timsrc})
Initialise an already allocated source structure.  This function applies
@cfunc{ccevents_source_init} to @var{timsrc}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Cast functions


@deftypefun {ccevents_timer_source_t *} ccevents_cast_to_timer_source_from_source (ccevents_source_t * @var{src})
Cast function which explicitly documents that this pointer type conversion is sometimes necessary.
We can use it, for example, in an event handler function as follows:

@example
void
event_handler (cce_location_t * there, ccevents_source_t * src)
@{
  ccevents_timer_source_t * timsrc =
    ccevents_cast_to_timer_source_from_source(src);
  ...
@}
@end example
@end deftypefun


@deftypefn {Generic Macro} {ccevents_timer_source_t *} ccevents_cast_to_timer_source (ccevents_source_t * @var{src})
Generic cast macro which explicitly documents that this pointer type conversion is sometimes
necessary.  We can use it, for example, in an event handler function as follows:

@example
void
event_handler (cce_location_t * there, ccevents_source_t * src)
@{
  ccevents_timer_source_t * timsrc =
    ccevents_cast_to_timer_source(src);
  ...
@}
@end example
@end deftypefn

@c ------------------------------------------------------------------------

@subsubheading Usage example


The task source is meant to be used as follows:

@smallexample
#include <ccevents.h>

void
timeout_handler (cce_location_t * there, ccevents_source_t * src)
@{
  ccevents_timer_source_t * timsrc = ccevents_cast_to_timer_source(src);
  // handle the timeout here
  ccevents_source_dequeue_itself(src);
@}

void
doit (void)
@{
  cce_location_t              L[1];
  ccevents_group_t            grp[1];
  ccevents_timer_source_t     timsrc[1];
  ccevents_timeout_t          expiration_to;
  ccevents_timeval_t          expiration_tv;

  if (cce_location(L)) @{
    cce_run_error_handlers(L);
    cce_condition_free(cce_condition(L));
  @} else @{
    ccevents_timer_source_init(timsrc);

    expiration_to = ccevents_timeout_init(L, 0, 0, 100);
    expiration_tv = ccevents_timeout_start(L, expiration_to);
    ccevents_source_set_timeout(timsrc, expiration_tv, timeout_handler);

    ccevents_group_init(grp, 100);
    ccevents_group_enqueue_source(grp, timsrc);

    ccevents_group_enter(grp);
  @}
@}
@end smallexample

@c page
@node sources fd
@section Event source for file descriptors


The file descriptor event source @api{} implements an event source associated to a single file
descriptor.  This @api{} is @strong{not} suitable for server programs that need to serve a ``high''
number of connections per second, but it should be easy to use, for example, to organise
communication between processes through pipes or socket pairs.

Internally these event sources use @cfunc{select}.  We must not share file descriptors between these
event sources and other code that consumes events.


@deftp {Struct Typedef} ccevents_fd_source_t
Type of structures representing events from file descriptors.  This structure type is ``derived''
from @objtype{ccevents_source_t}, meaning that the first field is anonymous of type
@objtype{ccevents_source_t}.
@end deftp


@deftypefun void ccevents_fd_source_init (ccevents_fd_source_t * @var{fdsrc}, int @var{fd})
Initialise an already allocated file descriptor event source.  The argument @var{fd} is the file
descriptor originating the events.
@end deftypefun


@deftypefun void ccevents_fd_source_set (ccevents_fd_source_t * @var{fdsrc}, ccevents_event_inquirer_t * @var{event_inquirer}, ccevents_event_handler_t * @var{event_handler})
Set up an already initialised file descriptor event source, referenced by @var{fdsrc}, to wait for
an event.  After the event represented by the arguments has been served or has expired: this
function can be called again for the same @var{fdsrc} to set up waiting for another event.

@var{event_inquirer} is a pointer to the function used to query the file descriptor for events.
This function decides which events are expected: readability, writability, exceptional condition.

@var{event_handler} is a pointer to the function used to handle a file descriptor event.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Inquirer functions


@value{PACKAGE} defines the following event inquirer functions.


@deftypevr Function ccevents_event_inquirer_t ccevents_query_fd_readability
Query a file descriptor for readability.  Return @true{} if the file descriptor is readable,
otherwise return @false{}.  If an error occurs: the value of @code{errno} might be mutated.  Beware
that some file descriptors are always readable.
@end deftypevr


@deftypevr Function ccevents_event_inquirer_t ccevents_query_fd_writability
Query a file descriptor for writability.  Return @true{} if the file descriptor is writable,
otherwise return @false{}.  If an error occurs: the value of @code{errno} might be mutated.  Beware
that some file descriptors are always writable.
@end deftypevr


@deftypevr Function ccevents_event_inquirer_t ccevents_query_fd_exception
Query a file descriptor for an exception; this is useful when the file descriptor is a network
socket.  Return @true{} if the file descriptor has received an exception signal, otherwise return
@false{}.  If an error occurs: the value of @code{errno} might be mutated.
@end deftypevr

@c ------------------------------------------------------------------------

@subsubheading Cast functions


@deftypefun {ccevents_fd_source_t *} ccevents_cast_to_fd_source_from_source (ccevents_source_t * @var{src})
Cast function which explicitly documents that this pointer type conversion is sometimes necessary.
We can use it, for example, in an event handler function as follows:

@example
void
event_handler (cce_location_t * there, ccevents_source_t * src)
@{
  ccevents_fd_source_t * fdsrc =
    ccevents_cast_to_fd_source_from_source(src);
  ...
@}
@end example
@end deftypefun


@deftypefn {Generic Macro} {ccevents_fd_source_t *} ccevents_cast_to_fd_source (ccevents_source_t * @var{src})
Generic cast macro which explicitly documents that this pointer type conversion is sometimes
necessary.  We can use it, for example, in an event handler function as follows:

@example
void
event_handler (cce_location_t * there, ccevents_source_t * src)
@{
  ccevents_fd_source_t * fdsrc =
    ccevents_cast_to_fd_source(src);
  ...
@}
@end example
@end deftypefn

@c ------------------------------------------------------------------------

@subsubheading Usage examples


To set up waiting for a readable event, in @math{5} seconds, on a pipe's file descriptor we can do
(using nested functions as allowed by a @gcc{} extension):

@smallexample
void event_handler (cce_location_t * there, ccevents_source_t * src)
@{
  ccevents_fd_source_t * fdsrc = ccevents_cast_to_fd_source(src);
  // We should do something here.
  ccevents_source_dequeue_itself(src);
@}

void expiration_handler (cce_location_t * there, ccevents_source_t * src)
@{
  ccevents_fd_source_t * fdsrc = ccevents_cast_to_fd_source(src);
  // We should do something here.
  ccevents_source_dequeue_itself(src);
@}

void
doit (void)
@{
  int                   X[2];
  cce_location_t        L[1];

  /* X[0] is the readable end.  X[1] is the writable end. */
  pipe(X);

  if (cce_location(L)) @{
    cce_run_error_handlers(L);
    cce_condition_free(cce_condition(L));
  @} else @{
    ccevents_group_t      grp[1];
    ccevents_fd_source_t  fdsrc[1];

    ccevents_fd_source_init(fdsrc, X[0]);
    ccevents_fd_source_set(fdsrc,
      ccevents_query_fd_readability, event_handler);

    @{
      ccevents_timeout_t  to = ccevents_timeout_init(L, 5, 0, 0);
      ccevents_timeval_t  tv = ccevents_timeout_start(L, to);
      ccevents_source_set_timeout(fdsrc, tv, expiration_handler);
    @}

    ccevents_group_init(grp);
    ccevents_group_enqueue_source(grp, fdsrc);
    ccevents_group_enter(grp, 10);

    cce_run_cleanup_handlers(L);
  @}
@}
@end smallexample

@c page
@node sources signals
@section Interprocess signals


The block/unblock (@bub{}) @api{} is a simplified interface to detect the arrival of interprocess
signals; if it does not suit the application's model, we should just ignore it.

@menu
* sources signals bub::         Setting up the block/unblock @api{}.
* sources signals sources::     Signals event sources.
@end menu

@c page
@node sources signals bub
@subsection Setting up the block/unblock @api{}


The following functions operate on global variables that are private to @value{PACKAGE}.  This makes
the @api{} multithreading unsafe.


@deftypefun void ccevents_signal_bub_init (void)
Initialise the @bub{} @api{}, enabling signal handling.  Block all the signals and register a
handler for each.

For all the signals, the function @cfunc{sigaction} is called with a reference to @objtype{struct
sigaction} in which the field @code{.sa_flags} has the following flags set: @code{SA_RESTART},
@code{SA_NOCLDSTOP}.
@end deftypefun


@deftypefun void ccevents_signal_bub_final (void)
Finalise the @bub{} @api{}, disabling signal handling.  Set all the handlers to @code{SIG_IGN}, then
unblock the signals.
@end deftypefun


@deftypefun void ccevents_signal_bub_acquire (void)
Unblock then block all the signals.  This causes blocked signals to be delivered.
@end deftypefun


@deftypefun bool ccevents_signal_bub_delivered (int @var{signum})
Return @true{} if the signal @var{signum} was delivered to this process since the last call to
@cfunc{ccevents_signal_bub_init}, @cfunc{ccevents_signal_bub_final} or
@cfunc{ccevents_signal_bub_delivered} with this value of @var{signum}.  Calling this function clears
the internal flag for signal @var{signum}.  If the return value is @false{}: the signal was not
delivered.

@strong{NOTE} We need to remember that it is not possible to reliably determine the number of
signals of a kind sent to a process, because in some cases multiple signals are merged together.
@end deftypefun


As usage example, the following program will print @samp{true} and exit successfully:

@example
#include <ccevents.h>
#include <assert.h>
#include <stdlib.h>
#include <signal.h>

int
main (int argc, const char *const argv[])
@{
  ccevents_signal_bub_init();
  @{
    bool        flag;
    raise(SIGUSR1);
    ccevents_signal_bub_acquire();
    flag = ccevents_signal_bub_delivered(SIGUSR1);
    fprintf(stderr, "delivered? %s\n", ((flag)? "true" : "false"));
  @}
  ccevents_signal_bub_final();
  exit(EXIT_SUCCESS);
@}
@end example

@c page
@node sources signals sources
@subsection Signals event sources


To use the @api{} described here we have to initialise the signals @bub{} @api{} by calling
@cfunc{ccevents_signal_bub_init}.


@deftp {Struct Typedef} ccevents_signal_bub_source_t
Type of data structures using signals as event source through the @bub{} @api{}.  Every instance of
this type uses a single signal as source.
@end deftp


@deftypefun void ccevents_signal_bub_source_init (ccevents_task_source_t * @var{src}, int @var{signum})
Initialise an already allocated source structure to react to the delivery of signals of type
@var{signum}.  Apply @cfunc{ccevents_source_init} to @var{src}.  Do not start the event waiting:
this is done by @cfunc{ccevents_signal_bub_source_set}.
@end deftypefun


@deftypefun void ccevents_signal_bub_source_set (ccevents_signal_source_t * @var{src}, ccevents_event_handler_t * @var{event_handler})
Start the waiting for the selected signal.  If an exceptional condition is raised: perform a
non--local exit by jumping to @var{there}.  We set only the event handler because the event inquirer
is selected internally.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Cast functions


@deftypefun {ccevents_signal_bub_source_t *} ccevents_cast_to_signal_bub_source_from_source (ccevents_source_t * @var{src})
Cast function which explicitly documents that this pointer type conversion is sometimes necessary.
We can use it, for example, in an event handler function as follows:

@example
void
event_handler (cce_location_t * there, ccevents_source_t * src)
@{
  ccevents_signal_bub_source_t * sigsrc =
    ccevents_cast_to_signal_bub_source_from_source(src);
  ...
@}
@end example
@end deftypefun


@deftypefn {Generic Macro} {ccevents_signal_bub_source_t *} ccevents_cast_to_signal_bub_source (ccevents_source_t * @var{src})
Generic cast macro which explicitly documents that this pointer type conversion is sometimes
necessary.  We can use it used, for example, in an event handler function as follows:

@example
void
event_handler (cce_location_t * there, ccevents_source_t * src)
@{
  ccevents_signal_bub_source_t * sigsrc =
    ccevents_cast_to_signal_bub_source(src);
  ...
@}
@end example
@end deftypefn

@c ------------------------------------------------------------------------

@subsubheading Usage example

As example, here is how to setup an event source to wait for the delivery of @samp{SIGUSR1}:

@smallexample
#include <ccevents.h>
#include <stdlib.h>
#include <signal.h>

static bool
acquire_signals_inquirer (cce_location_t * there, ccevents_source_t * src)
@{
  ccevents_signal_bub_acquire();
  return false;
@}

static volatile sig_atomic_t signal_flag = 0;

static void
signal_handler (cce_location_t * there, ccevents_source_t * src)
@{
  signal_flag = 1;
@}

int
main (int argc, const char *const argv[])
@{
  ccevents_group_t grp[1];

  /* This event source runs its inquirer function again
     and again to acquire signals with the BUB API. */
  ccevents_task_source_t acquire_signals_src[1];

  /* This event source reacts to the delivery of SIGUSR1. */
  ccevents_signal_bub_source_t sigsrc[1];

  cce_location_t L[1];

  ccevents_signal_bub_init();
  @{
    ccevents_group_init(grp);
    ccevents_task_source_init(acquire_signals_src);
    ccevents_signal_bub_source_init(sigsrc, SIGUSR1);

    if (cce_location(L)) @{
      cce_run_error_handlers(L);
      cce_condition_free(cce_condition(L));
    @} else @{
      ccevents_task_source_set(acquire_signals_src,
         acquire_signals_inquirer,
         ccevents_dummy_event_handler);
      ccevents_signal_bub_source_set(sigsrc, signal_handler);
      ccevents_group_enqueue_source(grp, sigsrc);
      ccevents_group_enqueue_source(grp, acquire_signals_src);
      ccevents_group_enter(grp, 1000);
      cce_run_cleanup_handlers(L);
    @}
  @}
  ccevents_signal_bub_final();
  exit(EXIT_SUCCESS);
@}
@end smallexample

@c page
@node groups
@chapter Groups of event sources


Groups are collections of event sources that must be queried for pending events with the same
priority.  Multiple groups are used to establish a priority order between sets of sources.  Events
from higher priority groups should be served before events from lower priority groups.  Most
programs will have one or two groups (one for high--priority events and one for batch processing,
like updating the Graphical User Interface).

An event source enqueued in a group may not have a pending event waiting to be served, so the group
can only ``attempt'' to serve an event source.

To avoid starving lower groups, we may configure the groups so that: every, say, @math{10} attempts
to serve an event from a higher group, we make @math{1} attempt to serve an event from a lower
group.


@deftp {Struct Typedef} ccevents_group_t
Type of groups of event sources.

Instances of this type must be initialised with a call to @cfunc{ccevents_group_init} applied to an
already allocated data structure.

Instances of this type must be finalised by calling @cfunc{ccevents_group_final}, and then, if
needed, by releasing the memory allocated for the data structure.
@end deftp


@deftypefun void ccevents_group_init (ccevents_group_t * @var{grp}, size_t @var{servicing_attempts_watermark})
Initialise an already allocated group structure.  The internal queue of event sources is initialised
to empty.  The number of attempts to serve events for each call to @cfunc{ccevents_group_enter} is
set to @var{servicing_attempts_watermark}.
@end deftypefun


@deftypefun void ccevents_group_final (ccevents_group_t * @var{src})
For any event source still associated to the group: apply @cfunc{ccevents_source_final} to the
pointer referencing the source.  This function is called by @cfunc{ccevents_loop_final} for any
group still enqueued in the loop.
@end deftypefun


@deftypefun void ccevents_group_enter (ccevents_group_t * @var{grp})
Enter the loop for this group and perform the configured number of attempts to serve events from the
enqueued sources, until:

@itemize
@item
The number of attempts reaches the configured watermark level.

@item
No more event sources are enqueued.  We need to remember that every time we attempt to serve an
event source: its methods might dequeue it from the group.

@item
A request to exit this group's loop is posted with @cfunc{ccevents_group_post_request_to_leave}.

@item
This group is enqueued in a loop and a request to exit the main loop is posted with
@cfunc{ccevents_loop_post_request_to_leave}.
@end itemize
@end deftypefun


@deftypefun void ccevents_group_post_request_to_leave (ccevents_group_t * @var{grp})
Post a request to exit as soon as possible the loop for this group.  This function is meant to be
called by an event handler to cause a premature return from a call to @cfunc{ccevents_group_enter}.
@end deftypefun


@deftypefun void ccevents_group_dequeue_itself (ccevents_group_t * @var{grp})
Remove the group @var{grp} from its loop.  If @var{grp} is not enqueued in a loop: nothing happens.
@end deftypefun


@deftypefun {ccevents_loop_t *} ccevents_group_get_loop (const ccevents_group_t * @var{group})
If the group is enqueued in a loop: return a pointer to that loop; otherwise return @false{}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Enqueuing and dequeuing sources


@deftypefun void ccevents_group_enqueue_source (ccevents_group_t * @var{grp}, ccevents_source_t * @var{src})
Enqueue the event source @var{src} in the group @var{grp}.  The new source becomes the ``current''
source and it is serviced at the next iteration of @cfunc{ccevents_group_enter}.
@end deftypefun


@deftypefun {ccevents_source_t *} ccevents_group_dequeue_source (ccevents_group_t * @var{grp})
Dequeue the next event source from the group @var{grp} and return it.  Return @cnull{} if the group
is empty.  By repeatedly calling this function: we can empty a group of all its enqueued sources.

@example
while (ccevents_group_queue_is_not_empty(grp)) @{
  ccevents_source_t *    src;
  src = ccevents_groups_dequeue_source(loop);
  /* Here we should finalise the source SRC. */
@}
@end example
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Inspection functions


@deftypefun bool ccevents_group_queue_is_not_empty (const ccevents_group_t * @var{grp})
Return @true{} if the group has at least one event source in the queue; otherwise return @false{}.
@end deftypefun


@deftypefun size_t ccevents_group_number_of_sources (const ccevents_group_t * @var{grp})
Return the number of event sources enqueued in @var{grp}.
@end deftypefun


@deftypefun bool ccevents_group_contains_source (const ccevents_group_t * @var{grp}, const ccevents_source_t * @var{src})
Return @true{} if the source @var{src} is enqueued in the group @var{grp}; otherwise return
@false{}.
@end deftypefun

@c page
@node loops
@chapter The main event loop


The main event loop contains references to groups of event sources that must be served.  Usage
example:

@example
#include <ccevents.h>

ccevents_loop_t         loop[1];
ccevents_group_t        grpA[1], grpB[1];

ccevents_loop_init(loop);
ccevents_group_init(grpA, 10);
ccevents_group_init(grpB, 5);

/* Here we should add event sources to the groups. */

ccevents_loop_enqueue_group(loop, grpA);
ccevents_loop_enqueue_group(loop, grpB);

ccevents_loop_enter(loop);

ccevents_loop_final(loop);
@end example


@deftp {Struct Typedef} ccevents_loop_t
Type of data structures representing a main event loop.

Instances of this type must be initialised with a call to @cfunc{ccevents_loop_init} applied to an
already allocated data structure.

Instances of this type must be finalised with a call to @cfunc{ccevents_loop_final} and then, if
needed, by releasing the memory allocated for the data structure.
@end deftp


@deftypefun void ccevents_loop_init (ccevents_loop_t * @var{loop})
Initialise an already allocated loop structure.  The internal queue of groups is initialised to
empty.
@end deftypefun


@deftypefun void ccevents_loop_final (ccevents_loop_t * @var{loop})
For any group still enqueued in the loop: apply @cfunc{ccevents_group_final} to the pointer
referencing the group.
@end deftypefun


@deftypefun void ccevents_loop_enter (ccevents_loop_t * @var{loop})
Enter the loop and serve events until:

@itemize
@item
No more groups are enqueued.

@item
A request to exit is posted with @cfunc{ccevents_loop_post_request_to_leave}.
@end itemize

Notice that empty groups are @strong{not} removed from a main loop; it is responsibility of the user
code to do it.  The right way to exit from a call to this function is to invoke
@cfunc{ccevents_loop_post_request_to_leave}.
@end deftypefun


@deftypefun void ccevents_loop_post_request_to_leave (ccevents_loop_t * @var{loop})
Post a request to exit as soon as possible the loop.  This function is meant to be called by an
event handler to cause a premature return from a call to @cfunc{ccevents_loop_enter}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Enqueuing and dequeuing groups


@deftypefun void ccevents_loop_enqueue_group (ccevents_loop_t * @var{loop}, ccevents_group_t * @var{grp})
Enqueue the group @var{grp} in @var{loop}.  The new group becomes the ``current'' group and it is
serviced at the next iteration of @cfunc{ccevents_loop_enter}.
@end deftypefun


@deftypefun {ccevents_group_t *} ccevents_loop_dequeue_group (ccevents_loop_t * @var{loop})
Dequeue a group from @var{loop} and return it.  Return @cnull{} if the loop is empty.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Inspection functions


@deftypefun size_t ccevents_loop_number_of_groups (const ccevents_loop_t * @var{loop})
Return the number of groups enqueued in @var{loop}.
@end deftypefun


@deftypefun bool ccevents_loop_contains_group (const ccevents_loop_t * @var{loop}, const ccevents_group_t * @var{grp})
Return @true{} if the group @var{grp} is enqueued in @var{loop}; otherwise return @false{}.
@end deftypefun


@deftypefun bool ccevents_loop_queue_is_not_empty (const ccevents_loop_t * @var{loop})
Return @true{} if this loop has at least one group in the queue; otherwise return @false{}.
@end deftypefun

@c page
@node helpers
@chapter Helper functions and macros


@deffn {Preprocessor Macro} CCEVENTS_PC (@var{TYPE}, @var{X}, @var{Y})
Pointer--type cast helper.  It expands into:

@example
@var{TYPE} * @var{X} = (@var{TYPE} *) (@var{Y})
@end example

So, for example, instead of writing:

@example
cce_location_t    L[1];
cce_condition_t * C = cce_condition(L);
ccevents_timeval_invalid_t * K = (ccevents_timeval_invalid_t *) C;
@end example

@noindent
we can write:

@example
cce_location_t    L[1];
cce_condition_t * C = cce_condition(L);
CCEVENTS_PC(ccevents_timeval_invalid_t, K, C);
@end example
@end deffn

@c page
@c ------------------------------------------------------------
@c Appendices.
@c ------------------------------------------------------------

@include lgpl-3.0.texi
@include fdl-1.3.texi

@c page
@node references
@appendix Bibliography and references


The documentation of @value{PACKAGE} is available online:

@center @value{DOCUMENTATION_URL}

@noindent
the latest release of this package can be downloaded from:

@center @value{DOWNLOAD_URL}

@noindent
development takes place at:

@center @value{GITHUB_URL}

@noindent
and as backup at:

@center @value{BITBUCKET_URL}

We can find the package  CCExceptions at:

@center @url{http://github.com/marcomaggi/ccexceptions/}

@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file

